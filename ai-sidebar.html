<!--
Copyright (c) 2024 Zheng He

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
-->


<script type="text/javascript">
    // Internationalization support
    let i18nMessages = {};
    
    // Get current page language
    function getCurrentLanguage() {
        let lang = 'zh-CN'; // Default language
        
        // Prefer using RED.i18n.lang() method
        if (RED.i18n && typeof RED.i18n.lang === 'function') {
            lang = RED.i18n.lang();
        } else if (RED.settings && typeof RED.settings.get === 'function') {
            lang = RED.settings.get('lang') || lang;
        }
        

        return lang;
    }
    
    // Load language files
    async function loadI18nMessages() {
        // Use RED.i18n.lang() to get current language
        let lang = 'zh-CN'; // Default language
        

        
        // Prefer using RED.i18n.lang() method
        if (RED.i18n && typeof RED.i18n.lang === 'function') {
            lang = RED.i18n.lang();

        } else {
            // Fallback method: RED.i18n.lang()
            if (RED.settings && typeof RED.settings.get === 'function') {
                lang = RED.i18n.lang() || lang;
            }
        }
        

        
        // Support multiple language formats
        let langFile;
        if (lang === 'en-US' || lang === 'en') {
            langFile = 'en-US';
        } else if (lang === 'ja' || lang === 'ja-JP') {
            langFile = 'ja';
        } else if (lang === 'zh-TW') {
            langFile = 'zh-TW';
        } else if (lang === 'de') {
            langFile = 'de';
        } else if (lang === 'es-ES' || lang === 'es') {
            langFile = 'es-ES';
        } else if (lang === 'fr') {
            langFile = 'fr';
        } else if (lang === 'ko') {
            langFile = 'ko';
        } else if (lang === 'pt-BR' || lang === 'pt') {
            langFile = 'pt-BR';
        } else if (lang === 'ru') {
            langFile = 'ru';
        } else {
            langFile = 'zh-CN';
        }
        

        
        // Load language files directly via fetch
        const fetchUrl = `ai-sidebar/locales/${langFile}/ai-sidebar.json`;

        
        try {
            const response = await fetch(fetchUrl);

            
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            
            const data = await response.json();

            
            // Extract data under ai-sidebar namespace
            if (data['ai-sidebar']) {
                i18nMessages = data['ai-sidebar'];
            } else {
                i18nMessages = data;
            }
            
            // Test if internationalization function works correctly


            
            updateUITexts();
        } catch (error) {

            // Use default English text as fallback
            i18nMessages = {
                sidebar: {
                    title: 'AI Assistant',
                    messages: {
                        welcome: 'Welcome to AI Assistant!'
                    }
                }
            };
            updateUITexts();
        }
    }
    
    // Internationalization function
    function _(key) {
        const keys = key.split('.');
        let value = i18nMessages;
        for (const k of keys) {
            value = value && value[k];
        }
        return value || key;
    }
    
    // Update UI text
    function updateUITexts() {
        // Delayed execution to ensure DOM elements are loaded
        setTimeout(() => {
            const showConfigBtn = document.querySelector('#show-config-node-button');
            const sendBtn = document.querySelector('#send-button');
            const clearBtn = document.querySelector('#clear-button');
            const userInput = document.querySelector('#user-input');
            const scenarioLabel = document.querySelector('#scenario-label');
            const sendButtonText = document.querySelector('#send-button-text');
            const chatHistoryLabel = document.querySelector('#chat-history-label');
            
            // Handle all elements with data-i18n attribute
            const i18nElements = document.querySelectorAll('[data-i18n]');
            i18nElements.forEach(element => {
                const key = element.getAttribute('data-i18n');
                if (key) {
                    element.textContent = _(key);
                }
            });
            
            if (showConfigBtn) showConfigBtn.textContent = _('sidebar.buttons.showConfig');
            if (sendBtn) sendBtn.textContent = _('sidebar.buttons.send');
            if (clearBtn) clearBtn.textContent = _('sidebar.buttons.clear');
            if (userInput) userInput.placeholder = _('sidebar.placeholders.inputMessage');
            if (scenarioLabel) scenarioLabel.textContent = _('sidebar.labels.scenario');
            if (sendButtonText) sendButtonText.textContent = _('sidebar.buttons.send');
            if (chatHistoryLabel) chatHistoryLabel.textContent = _('sidebar.labels.chatHistory');
        }, 100);
    }
    
    // Global error handler
    
    // Monitor Node-RED language changes
    function watchLanguageChange() {
        let currentLang = RED.i18n.lang() || 'zh-CN';
        console.log('üåê Initial language detected:', currentLang);
        // Check for language setting changes once after startup
        setTimeout(async () => {
            const newLang = RED.i18n.lang() || 'zh-CN';
            const settingsLang = RED.settings ? RED.settings.get('lang') : 'unknown';
            console.log('üîç Language check - Current:', currentLang, 'New:', newLang, 'Settings:', settingsLang);
            
            if (newLang !== currentLang) {
                console.log('üîÑ Language changed from', currentLang, 'to', newLang);
                currentLang = newLang;
                await loadI18nMessages(); // Reload language files
                // Check for unregistered nodes before updating backend language
                const unregisteredNodes = checkForUnregisteredNodes();
                
                if (unregisteredNodes.length == 0) {
                    // Notify backend to update LangChainManager language
                    try {
                        console.log('üì° Sending language update to backend:', newLang);
                        const response = await fetch('/ai-sidebar/update-language', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({ language: newLang })
                        });
                        
                        if (response.ok) {
                            const result = await response.json();
                            console.log('‚úÖ Backend language updated successfully:', result);
                        } else {
                            console.warn('‚ùå Failed to update backend language:', response.status);
                        }
                    } catch (error) {
                        console.warn('‚ùå Error updating backend language:', error);
                    }
                 }
            }
        }, 2000);
    }
    
    // Initialize internationalization after page load
    $(document).ready(async function() {
        await loadI18nMessages();
        
        // Initialize backend language on page load
        const initialLang = getCurrentLanguage();
        
        // Check for unregistered nodes before initializing backend language
        const unregisteredNodes = checkForUnregisteredNodes();
        if (unregisteredNodes.length == 0) {
            try {
                console.log('üöÄ Initializing backend language:', initialLang);
                const response = await fetch('/ai-sidebar/update-language', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ language: initialLang })
                });
                
                if (response.ok) {
                    const result = await response.json();
                    console.log('‚úÖ Backend language initialized successfully:', result);
                } else {
                    console.warn('‚ùå Failed to initialize backend language:', response.status);
                }
            } catch (error) {
                console.warn('‚ùå Error initializing backend language:', error);
            }
        }
        
        watchLanguageChange(); // Start language change monitoring
    })
    window.addEventListener('error', function(e) {
        // Global error handler - errors are handled silently
    });
    
    // Fix undefined label error in Node-RED debug message handling
    // Save original handleDebugMessage function (if exists)
    var originalHandleDebugMessage = window.handleDebugMessage;
    
    window.handleDebugMessage = function(data) {
        try {
            // If data is an array, process each element
            if (data && Array.isArray(data)) {
                data = data.map(function(item) {
                    // Ensure each item has a label property, provide default if missing
                    if (item && typeof item === 'object' && !item.label) {
                        item.label = item.name || item.id || item.type || 'Unknown';
                    }
                    return item;
                });
            }
            
            // If original function exists, call it
            if (originalHandleDebugMessage && typeof originalHandleDebugMessage === 'function') {
                return originalHandleDebugMessage.call(this, data);
            }
            
            return data;
        } catch (error) {

            // If error occurs, try calling original function
            if (originalHandleDebugMessage && typeof originalHandleDebugMessage === 'function') {
                try {
                    return originalHandleDebugMessage.call(this, data);
                } catch (e) {

                }
            }
            return data;
        }
    };
    
    var currentStreamMessageId = null;
        // Scenario Manager - moved to front for definition
    var ScenarioManager = {
        currentScenario: 'learning',
        scenarios: {},
        isLoaded: false,
        
        init: function() {

            
            // Load scenario data from backend
            return this.loadScenarios().then(() => {
                // Bind scenario selection events
                $("#scenario-selector").on("change", function() {
                    var selectedScenario = $(this).val();
                    ScenarioManager.switchScenario(selectedScenario);
                });
                
                // Initialize default scenario
                this.updateUI();
                
                // Remove welcome dialog display
            }).catch(error => {

                // Use default scenario data as fallback
                this.scenarios = {
                    learning: {
                        name: _("sidebar.scenarios.learning.name"),
                        description: _("sidebar.scenarios.learning.description"),
                        prompt: []
                    }
                };
                this.isLoaded = true;
                this.updateUI();
            });
        },
        
        loadScenarios: function() {
            return new Promise((resolve, reject) => {

                
                // Get current language and pass to backend
                const currentLang = getCurrentLanguage();
                const url = `/ai-sidebar/scenarios?lang=${encodeURIComponent(currentLang)}`;
                
                fetch(url)
                    .then(response => {
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        return response.json();
                    })
                    .then(data => {

                        this.scenarios = data;
                        this.isLoaded = true;
                        resolve(data);
                    })
                    .catch(error => {

                        reject(error);
                    });
            });
        },
        
        // showWelcomeDialogÂáΩÊï∞Â∑≤ÁßªÈô§
        
        switchScenario: function(scenarioId) {
            // Get actual scenario data
            var scenarios = this.scenarios.scenarios || this.scenarios;
            
            if (!scenarios[scenarioId]) {

                return;
            }
            
            this.currentScenario = scenarioId;
            this.updateUI();
            
            // Send scenario switch message (removed auto-call LLM logic)
            var scenario = scenarios[scenarioId];
            
            // Build message content with prompt buttons
            var messageContent = _("sidebar.messages.scenarioSwitched").replace("{scenarioName}", scenario.name).replace("{description}", scenario.description);
            
            // If scenario has prompt templates, add buttons
            if (scenario.prompt && Array.isArray(scenario.prompt) && scenario.prompt.length > 0) {
                messageContent += '\n\n' + _("sidebar.messages.quickStart");
                var promptButtons = scenario.prompt.map(function(prompt) {
                    return `<button class="prompt-template-btn" data-prompt="${prompt.replace(/"/g, '&quot;')}" style="padding: 6px 12px; background: rgb(229, 231, 235); border: none; border-radius: 16px; text-align: center; cursor: pointer; transition: 0.2s; font-size: 11px; line-height: 1.2; color: rgb(55, 65, 81); display: inline-block; margin: 2px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 200px; transform: scale(1);" onmouseover="this.style.background='#d1d5db'; this.style.transform='scale(1.05)';" onmouseout="this.style.background='#e5e7eb'; this.style.transform='scale(1)';" onclick="document.getElementById('augment-chat-input').value='${prompt.replace(/'/g, "\\'")}'">${prompt}</button>`;
                }).join('');
                messageContent += `\n<div class="prompt-template-container">${promptButtons}</div>`;
            }
            
            addMessageToChat('system', messageContent);
            
            // Scroll to bottom
            forceScrollToBottom();
        },
        
        updateUI: function() {
            // Get actual scenario data structure
            var scenarios = this.scenarios.scenarios || this.scenarios;
            var scenario = scenarios[this.currentScenario];
            
            if (!scenario) {

                return;
            }
            // Update input placeholder
            $("#augment-chat-input").attr('placeholder', _("sidebar.placeholders.inputMessage").replace("{scenarioName}", scenario.name));
            
            // Update selector value
            $("#scenario-selector").val(this.currentScenario);
            
            // Update current scenario display
            $("#current-scenario-name").text(scenario.name);
        },
        
        getCurrentScenario: function() {
            return this.currentScenario;
        }
    };
    // Function to update current flow name
    function updateCurrentFlowName() {
        try {
            // Get current active workspace
            var activeWorkspace = RED.workspaces.active();
            
            if (activeWorkspace) {
                // Get workspace node
                var workspaceNode = RED.nodes.workspace(activeWorkspace);
                
                if (workspaceNode && workspaceNode.label) {
                    // Update displayed flow name
                    $("#current-flow-name").text(workspaceNode.label);
                } else {
                    $("#current-flow-name").text("Flow " + activeWorkspace);
                }
            } else {
                $("#current-flow-name").text(_("sidebar.labels.noFlowSelected"));
            }
        } catch (error) {

            $("#current-flow-name").text(_("sidebar.labels.unknownFlow"));
        }
    }

    // Function to update current selected node info
    function updateSelectedNodeInfo() {
        try {
            var selection = RED.view.selection();
            
            if (!selection || !selection.nodes || selection.nodes.length === 0) {
                $("#current-selected-node").text(_("sidebar.labels.noNodeSelected"));
                $("#selected-node-type-container").hide();
            } else if (selection.nodes.length === 1) {
                var node = selection.nodes[0];
                var nodeInfo = node.name || node.type || _("sidebar.labels.unknownNode");
                $("#current-selected-node").text(nodeInfo);
                
                // Display node type
                if (node.type) {
                    $("#current-selected-node-type").text(node.type);
                    $("#selected-node-type-container").show();
                } else {
                    $("#selected-node-type-container").hide();
                }
            } else {
                $("#current-selected-node").text(selection.nodes.length + " " + _("sidebar.labels.multipleNodesSelected"));
                $("#selected-node-type-container").hide();
            }
        } catch (error) {

            $("#current-selected-node").text(_("sidebar.labels.unknownNode"));
            $("#selected-node-type-container").hide();
        }
    }
    
    function setupAIAssistant() {
        // Auto-adjust textarea height
        $("#augment-chat-input").on("input", function() {
            this.style.height = "auto";
            this.style.height = Math.min(this.scrollHeight, 120) + "px";
        });
        
        // Send button click event
        $("#augment-send").on("click", function() {
            var sendButton = $(this);
            
            // Check if button is in loading state (AI is responding)
            if (sendButton.attr('data-loading') === 'true') {
                // Stop AI response
                stopAIResponse();
            } else {
                // Normal send message
                sendMessage();
            }
        });
        
        // Send message on Enter key (Shift+Enter for line break)
        $("#augment-chat-input").on("keydown", function(e) {
            if (e.key === "Enter" && !e.shiftKey) {
                e.preventDefault();
                sendMessage();
            }
        });
        
        // Tool button click event
        $("#augment-attach-file").on("click", function() {
            RED.notify(_("sidebar.messages.developing"), "info");
        });

        // Apply custom internationalization to elements with data-i18n attributes
        updateUITexts();

        // Note: @ button event binding moved to sidebar initialization
    }
    
    // Preprocess ACTION_TYPE markers, convert to executable buttons
    // Preprocess: Handle ACTION_TYPE markers
    function preprocessActionType(content) {
        // Find combination of ACTION_TYPE and JSON code blocks
        const actionPattern = /ACTION_TYPE:\s*(\w+)([\s\S]*?)```json\s*([\s\S]*?)\s*```/gi;
        
        return content.replace(actionPattern, function(match, actionTypeMatch, middleContent, jsonContent) {
            
            // If EXPLAIN type, don't add button markers
            if (actionTypeMatch.toUpperCase() === 'EXPLAIN') {
                return match; // Keep original content unchanged
            }
            
            try {
                // Validate JSON format
                JSON.parse(jsonContent);
                
                // Add action markers for non-EXPLAIN types
                var actionId = 'action-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
                
                return match + `\n\n<div class="action-marker" data-action-type="${actionTypeMatch.toUpperCase()}" data-json-content="${encodeURIComponent(jsonContent)}" data-action-id="${actionId}" style="display: none;"></div>`;
                
            } catch (e) {

                return match;
            }
        });
    }
    // Function to check for unregistered nodes in current flow
    function checkForUnregisteredNodes() {
        var unregisteredNodes = [];
        RED.nodes.eachNode(function(node) {
            // Check if node type is registered
            // console.log("checkForUnregisteredNodes",node)
            var nodeType = node.type;
            if (nodeType=='unknown') {
                unregisteredNodes.push({
                    id: node.id,
                    type: node.type,
                    name: node.name || node.type
                });
            }
        });
        return unregisteredNodes;
    }
    
    // Function to show unregistered nodes dialog
     function showUnregisteredNodesDialog(unregisteredNodes) {
         var nodeListMarkdown = unregisteredNodes.map(function(node, index) {
             return `**${index + 1}. ${node.name}** \`(${node.type})\`\n\n` +
                    `üîß [ÂÆâË£ÖËäÇÁÇπ](javascript:installNode('${node.name}')) | ` +
                    `üóëÔ∏è [Âà†Èô§ËäÇÁÇπ](javascript:deleteNode('${node.id}'))`;
         }).join('\n\n---\n\n');
         
         var message = `${_('sidebar.messages.unregisteredNodesDetected')}\n\n` +
                      `${nodeListMarkdown}\n\n` +
                      `${_('sidebar.messages.unregisteredNodesSuggestion')}`;
         
         addMessageToChat("system", message);
         return false;
     }

     // Function to install a node using Node-RED HTTP API
     async function installNode(nodeType) {
         try {
             addMessageToChat("system", _("sidebar.messages.installingNode", {nodeType: nodeType}));
             
             // Use Node-RED Admin API to install the node
             const response = await fetch('/nodes', {
                 method: 'POST',
                 headers: {
                     'Content-Type': 'application/json'
                 },
                 body: JSON.stringify({
                     module: nodeType
                 })
             });
             
             if (response.ok) {
                 const result = await response.json();
                 addMessageToChat("system", _("sidebar.messages.nodeInstallSuccess", {nodeType: nodeType, version: result.version}));
                 
                 // Refresh the palette to show the new node
                 if (RED && RED.palette && RED.palette.refresh) {
                     RED.palette.refresh();
                 }
                 
                 // Check if there are still unregistered nodes
                 setTimeout(() => {
                     var remainingUnregistered = checkForUnregisteredNodes();
                     if (remainingUnregistered.length === 0) {
                         addMessageToChat("system", _("sidebar.messages.allNodesInstalled"));
                     }
                 }, 1000);
                 
             } else {
                 const error = await response.text();
                 addMessageToChat("system", _("sidebar.messages.nodeInstallFailed", {nodeType: nodeType, error: error}));
                 
                 // Fallback: show manual installation instructions
                 var installMessage = `\n\n${_("sidebar.messages.manualInstallTitle")}\n\n` +
                                    _("sidebar.messages.manualInstallStep1", {nodeType: nodeType}) + "\n\n" +
                                    _("sidebar.messages.manualInstallStep2");
                 addMessageToChat("system", installMessage);
             }
         } catch (error) {
             addMessageToChat("system", _("sidebar.messages.nodeInstallError", {error: error.message}));
             
             // Fallback: show manual installation instructions
             var installMessage = `\n\n${_("sidebar.messages.manualInstallTitle")}\n\n` +
                                _("sidebar.messages.manualInstallStep1", {nodeType: nodeType}) + "\n\n" +
                                _("sidebar.messages.manualInstallStep2");
             addMessageToChat("system", installMessage);
         }
     }

     // Function to delete a node
     function deleteNode(nodeId) {
         // Remove the node from the workspace
         var node = RED.nodes.node(nodeId);
         if (node) {
             RED.nodes.remove(nodeId);
             RED.view.redraw();
             addMessageToChat("system", _("sidebar.messages.nodeDeleted", {nodeName: node.name || node.type}));
             
             // Deploy the changes to make them effective
             if (RED && RED.deploy) {
                //  RED.deploy.setDeployInflight(true);
                //    RED.nodes.dirty(true);

            RED.deploy.setDeployInflight(false);
            RED.nodes.dirty(true);


                //  RED.deploy();
                //  addMessageToChat("system", "üöÄ Ê≠£Âú®ÈÉ®ÁΩ≤ÊµÅÁ®ãÂèòÊõ¥...");
             }
             
             // Check if there are still unregistered nodes
             var remainingUnregistered = checkForUnregisteredNodes();
             if (remainingUnregistered.length === 0) {
                 addMessageToChat("system", _("sidebar.messages.allNodesProcessed"));
             }
         } else {
             addMessageToChat("system", _("sidebar.messages.nodeNotFound", {nodeId: nodeId}));
         }
     }

    async function sendMessage() {
        var message = $("#augment-chat-input").val().trim();
        console.log(_("sidebar.messages.startingChat"), message)
        if (message) {
            // 1. Check for unregistered nodes in current flow
            var unregisteredNodes = checkForUnregisteredNodes();
            
            // 2. If unregistered nodes exist, show dialog and stop
            if (unregisteredNodes.length > 0) {
                showUnregisteredNodesDialog(unregisteredNodes);
                return; // Stop further chat process
            }
            
            // 3. If no unregistered nodes, continue with normal chat process
            // Set send button to loading state
            setSendButtonLoading(true);

            addMessageToChat("user", message);
            
            $("#augment-chat-input").val("");
            $("#augment-chat-input").css("height", "72px");
            
            try {
                // Send to AI backend
                await sendToAI(message, false); // Explicitly specify not silent send
            } catch (error) {
                // Only reset loading state on error, not on success
                // Success case will be handled by handleStreamData when response completes
                console.error('Error sending message:', error);
                setSendButtonLoading(false);
            }
        }
    }
    
    // Function to set send button loading state
    function setSendButtonLoading(isLoading) {
        var sendButton = $("#augment-send");
        var sendButtonText = $("#send-button-text");
        var sendButtonIcon = sendButton.find("i");
        
        if (isLoading) {
            // Store original state
            window.originalSendButtonState = {
                text: sendButtonText.text(),
                icon: sendButtonIcon.attr('class'),
                disabled: sendButton.prop('disabled')
            };
            
            // Set loading state
            sendButton.prop('disabled', false); // Keep enabled for stop functionality
            sendButtonIcon.attr('class', 'fa fa-spinner fa-spin');
            sendButtonText.text(_('sidebar.buttons.stop'));
            sendButton.attr('data-loading', 'true');
            
            // Store current request for potential cancellation
            window.isAIResponding = true;
        } else {
            // Restore original state
            if (window.originalSendButtonState) {
                sendButton.prop('disabled', window.originalSendButtonState.disabled);
                sendButtonIcon.attr('class', window.originalSendButtonState.icon);
                sendButtonText.text(window.originalSendButtonState.text);
                sendButton.removeAttr('data-loading');
                
                window.originalSendButtonState = null;
            }
            window.isAIResponding = false;
        }
    }
    
    // Function to stop AI response
    function stopAIResponse() {
        console.log(_("sidebar.messages.frontendStopAI"));
        
        if (window.currentAbortController) {
            console.log(_("sidebar.messages.executingAbort"));
            // Abort the current request
            window.currentAbortController.abort();
            window.currentAbortController = null;
        } else {
            console.log(_("sidebar.messages.noAbortController"));
        }
        
        // Reset send button state
        setSendButtonLoading(false);
        
        // Clear current stream message ID
        if (window.currentStreamMessageId) {
            // Add a stop indicator to the current message
            appendToMessage(window.currentStreamMessageId, "\n\n‚èπÔ∏è *" + _('sidebar.messages.responseStopped') + "*");
            window.currentStreamMessageId = null;
        }
        
        console.log(_("sidebar.messages.aiResponseStopped"));
    }

    // Get development scenario keywords for current node detection
    async function getDevelopmentNodeKeywords() {
        try {
            const currentLang = getCurrentLanguage();
            const configUrl = `/ai-sidebar/scenarios?lang=${encodeURIComponent(currentLang)}`;
            const response = await fetch(configUrl);
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            const data = await response.json();
            const scenarios = data.scenarios || data;
            
            // Find development scenario keywords for current node
            if (scenarios.development && scenarios.development.keywords) {
                for (const keywordConfig of scenarios.development.keywords) {
                    if (keywordConfig.scenario === 'development' && 
                        keywordConfig.newHumanPrompt && 
                        keywordConfig.newHumanPrompt.includes('get-node-info')) {
                        return keywordConfig.key || [];
                    }
                }
            }
            return [];
        } catch (error) {
            console.error('Error getting development node keywords:', error);
            return [];
        }
    }

    // Get development scenario keywords for current flow detection
    async function getDevelopmentFlowKeywords() {
        try {
            const currentLang = getCurrentLanguage();
            const configUrl = `/ai-sidebar/scenarios?lang=${encodeURIComponent(currentLang)}`;
            const response = await fetch(configUrl);
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            const data = await response.json();
            const scenarios = data.scenarios || data;
            
            // Find development scenario keywords for current flow
            if (scenarios.development && scenarios.development.keywords) {
                for (const keywordConfig of scenarios.development.keywords) {
                    if (keywordConfig.scenario === 'development' && 
                        keywordConfig.newHumanPrompt && 
                        keywordConfig.newHumanPrompt.includes('get-flow')) {
                        return keywordConfig.key || [];
                    }
                }
            }
            return [];
        } catch (error) {
            console.error('Error getting development flow keywords:', error);
            return [];
        }
    }

    // Detect keywords from configuration file
    async function detectKeywords(message) {
        try {
            const currentLang = getCurrentLanguage();
            
            const configUrl = `/ai-sidebar/scenarios?lang=${encodeURIComponent(currentLang)}`;
            
            const response = await fetch(configUrl);
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            const data = await response.json();
            
            // Check data structure, unwrap if has scenarios wrapper
            const scenarios = data.scenarios || data;
            
            const lowerMessage = message.toLowerCase();
            
            // Iterate through all scenario keyword configurations
            for (const [scenarioKey, scenarioConfig] of Object.entries(scenarios)) {
                if (scenarioConfig.keywords) {
                    for (let i = 0; i < scenarioConfig.keywords.length; i++) {
                        const keywordConfig = scenarioConfig.keywords[i];
                        // Check if matches any keywords
                        for (const keyword of keywordConfig.key) {
                            const lowerKeyword = keyword.toLowerCase();
                            if (lowerMessage.includes(lowerKeyword)) {
                                return {
                                    scenario: keywordConfig.scenario,
                                    newHumanPrompt: keywordConfig.newHumanPrompt,
                                    matchedKeyword: keyword
                                };
                            }
                        }
                    }
                }
            }
            
            return null; // No matching keywords
        } catch (error) {
            // If fetch fails, try default English configuration
            try {
                const response = await fetch('/ai-sidebar/scenarios?lang=en-US');
                const data = await response.json();
                
                // Check data structure, unwrap if has scenarios wrapper
                const scenarios = data.scenarios || data;
                const lowerMessage = message.toLowerCase();
                
                for (const [scenarioKey, scenarioConfig] of Object.entries(scenarios)) {
                    if (scenarioConfig.keywords) {
                        for (const keywordConfig of scenarioConfig.keywords) {
                            for (const keyword of keywordConfig.key) {
                                if (lowerMessage.includes(keyword.toLowerCase())) {
                                    return {
                                        scenario: keywordConfig.scenario,
                                        newHumanPrompt: keywordConfig.newHumanPrompt,
                                        matchedKeyword: keyword
                                    };
                                }
                            }
                        }
                    }
                }
                return null;
            } catch (fallbackError) {

                return null;
            }
        }
    }

    async function sendToAI(message, silent = false) {
        var nodeId = getSelectedConfigNodeId();
        if (!nodeId) {
            if (!silent) {
                addMessageToChat("error", "‚ùå Configuration node not found, please create and configure API key first");
            }
            throw new Error("Configuration node not found");
        }

        // Check if node is deployed
        var configNode = RED.nodes.node(nodeId);
        if (!configNode) {
            if (!silent) {
                addMessageToChat("error", _("sidebar.messages.configNodeNotDeployed"));
            }
            throw new Error("Configuration node not deployed");
        }

        // Check if there are undeployed changes
        if (RED.nodes.dirty()) {
            if (!silent) {
                addMessageToChat("warning", _("sidebar.messages.undeployedChanges"));
            }
            throw new Error("Undeployed changes detected");
        }

        // Get current scenario
        var currentScenario = ScenarioManager.getCurrentScenario();


        // Get current selected flow and node information
        var selectedFlow = null;
        var selectedNodes = [];
        var flowData = null;

        try {
            // Get current active workspace
            var activeWorkspace = RED.workspaces.active();
            if (activeWorkspace) {
                var workspaceObj = RED.nodes.workspace(activeWorkspace);
                if (workspaceObj) {
                    selectedFlow = {
                        id: workspaceObj.id,
                        label: workspaceObj.label || 'Untitled Flow'
                    };
                }
            }
            
            // Get selected nodes
            var selection = RED.view.selection();
            if (selection && selection.nodes) {
                selectedNodes = selection.nodes.map(node => ({
                    id: node.id,
                    type: node.type,
                    name: node.name || '',
                    x: node.x,
                    y: node.y,
                    wires: node.wires || [],
                    config: Object.keys(node).reduce((config, key) => {
                        if (!['credentials', 'apiKey', 'password', 'token'].includes(key) && 
                            !key.startsWith('_') && 
                            typeof node[key] !== 'function') {
                            config[key] = node[key];
                        }
                        return config;
                    }, {})
                }));

            }
        } catch (error) {

        }

        // Build the message to send, if empty message then send scenario initialization request
        var sendMessage = message.trim();
        if (!sendMessage) {
            var scenario = ScenarioManager.scenarios[currentScenario];
            sendMessage = _("sidebar.messages.scenarioInitialGuidance", {scenarioName: scenario.name});
        }

        // Initialize dynamic data for tool usage
        var dynamicData = {};
        
        // Detect keywords from config file and handle scenario switching
        const keywordDetected = await detectKeywords(sendMessage);
        
        if (keywordDetected) {
            // Auto switch scenario only if different
            if (currentScenario !== keywordDetected.scenario) {
                currentScenario = keywordDetected.scenario;
                ScenarioManager.switchScenario(keywordDetected.scenario);
            }
            
            // Get tool name from newHumanPrompt
            const toolName = keywordDetected.newHumanPrompt;
            const originalMessage = sendMessage;
            
            // Build @tools format message based on tool requirements
            if (toolName === 'get-flow') {
                if (selectedFlow && selectedFlow.id) {
                    sendMessage = `@tools:get-flow|['${selectedFlow.id}']`;
                    dynamicData.flowId = selectedFlow.id;
                    console.log(_('sidebar.toolCalls.flowDetectionLog'), selectedFlow.id);
                } else {
                    sendMessage = `@tools:get-flow`;
                }
            } else if (toolName === 'get-node-info') {
                if (selectedNodes && selectedNodes.length > 0) {
                    const nodeIds = selectedNodes.map(node => `'${node.id}'`).join(',');
                    sendMessage = `@tools:get-node-info|[${nodeIds}]`;
                    dynamicData.selectedNodes = selectedNodes;
                } else {
                    // Show error message when node tool detected but no nodes selected
                    var errorMessage = "‚ùå " + _("sidebar.messages.noNodesSelected");
                    addMessageToChat("error", errorMessage);
                    setSendButtonLoading(false);
                    return;
                }
            } else if (toolName === 'get-settings') {
                sendMessage = `@tools:get-settings`;
            } else if (toolName === 'get-diagnostics') {
                sendMessage = `@tools:get-diagnostics`;
            } else {
                // Fallback to original behavior for unknown tools
                sendMessage = originalMessage;
            }
        }

        
        // Create loading message with animation
        var loadingMessageId = "loading-" + Date.now();
        var aiMessageId = "ai-" + Date.now();
        var loadingContent = `**loading...**`;
        addMessageToChat("assistant", loadingContent, loadingMessageId);
        
        // Store current loading message ID for later replacement
        window.currentLoadingMessageId = loadingMessageId;
        
        // Create AbortController for request cancellation
        window.currentAbortController = new AbortController();
        
        // Send request after asynchronously getting chat history
        getChatHistory(function(history) {
            // Reconstruct sendMessage to ensure proper @tools format
            if (sendMessage.startsWith('@tools:')) {
                // Message already in @tools format, keep as is
                console.log('Using @tools format message:', sendMessage);
            } else {
                // Regular message, keep as is
                console.log('Using regular message:', sendMessage);
            }
            
                console.log('Request sent',JSON.stringify({
                    message: sendMessage,
                    scenario: currentScenario,  // Add scenario information
                    sessionId: getCurrentSessionId(),  // Add session ID
                    nodeId: nodeId,
                    selectedFlow: selectedFlow,
                    selectedNodes: selectedNodes,
                    flowData: flowData,
                    history: history,  // Use asynchronously obtained history
                    silent: silent,  // Add silent flag
                    dynamicData: dynamicData,  // Add dynamic data
                    language: getCurrentLanguage()  // Add current page language
                }));
            fetch('/ai-sidebar/stream-chat', {
                signal: window.currentAbortController.signal,
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json; charset=utf-8',
                },
                body: JSON.stringify({
                    message: sendMessage,
                    scenario: currentScenario,  // Add scenario information
                    sessionId: getCurrentSessionId(),  // Add session ID
                    nodeId: nodeId,
                    selectedFlow: selectedFlow,
                    selectedNodes: selectedNodes,
                    flowData: flowData,
                    history: history,  // Use asynchronously obtained history
                    silent: silent,  // Add silent flag
                    dynamicData: dynamicData,  // Add dynamic data
                    language: getCurrentLanguage()  // Add current page language
                })
                
            })
        .then(response => {
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            
            const reader = response.body.getReader();
            const decoder = new TextDecoder('utf-8');
            
            function readStream() {
                // Ê£ÄÊü•ÊòØÂê¶Â∑≤Ë¢´‰∏≠Ê≠¢
                if (window.currentAbortController && window.currentAbortController.signal.aborted) {
                    console.log('üõë Ê£ÄÊµãÂà∞abort‰ø°Âè∑ÔºåÂÅúÊ≠¢ËØªÂèñÊµÅ');
                    reader.cancel();
                    return Promise.resolve();
                }
                
                return reader.read().then(({ done, value }) => {
                    // ÂÜçÊ¨°Ê£ÄÊü•ÊòØÂê¶Â∑≤Ë¢´‰∏≠Ê≠¢
                    if (window.currentAbortController && window.currentAbortController.signal.aborted) {
                        console.log('üõë ËØªÂèñËøáÁ®ã‰∏≠Ê£ÄÊµãÂà∞abort‰ø°Âè∑ÔºåÂÅúÊ≠¢ËØªÂèñÊµÅ');
                        reader.cancel();
                        return Promise.resolve();
                    }
                    
                    if (done) {
                        return;
                    }
                    
                    const chunk = decoder.decode(value);
                    const lines = chunk.split('\n');
                    
                    for (const line of lines) {
                        if (line.startsWith('data: ')) {
                            try {
                                const jsonStr = line.slice(6);
                                const data = JSON.parse(jsonStr);
                                handleStreamData(data, loadingMessageId);
                            } catch (e) {
                                // Ignore parsing errors
                            }
                        }
                    }
                    
                    return readStream();
                });
            }
            
            return readStream();
        })
        .catch(error => {
            // Check if request was aborted
            if (error.name === 'AbortError') {
                console.log('üõë AIÂìçÂ∫îÂ∑≤Ë¢´Áî®Êà∑‰∏≠Êñ≠');
                $("#" + loadingMessageId).remove();
                addMessageToChat("system", "‚èπÔ∏è " + _("sidebar.messages.responseStopped"));
                // Reset loading state when aborted
                setSendButtonLoading(false);
                return;
            }
            
            console.error('üî• ÊµÅÂºèËÅäÂ§©ËØ∑Ê±ÇÂ§±Ë¥•:', error);
            console.error('üî• ÈîôËØØËØ¶ÊÉÖ:', error.message, error.stack);
            $("#" + loadingMessageId).remove();
            
            var errorMessage = "‚ùå AIËØ∑Ê±ÇÂ§±Ë¥•: " + error.message;
            addMessageToChat("error", errorMessage);
            
            // Reset loading state on error
            setSendButtonLoading(false);
            
            // Check if network or authentication related error, show RED.notify notification
            if (error.message.includes('401') || error.message.includes('403') || 
                error.message.includes('Unauthorized') || error.message.includes('API key')) {
                RED.notify('APIÂØÜÈí•ËÆ§ËØÅÂ§±Ë¥•ÔºåËØ∑Ê£ÄÊü•ÈÖçÁΩÆËäÇÁÇπ‰∏≠ÁöÑAPIÂØÜÈí•ÊòØÂê¶Ê≠£Á°Æ', 'error');
            } else {
                RED.notify('AIÊúçÂä°ËøûÊé•Â§±Ë¥•ÔºåËØ∑Ê£ÄÊü•ÁΩëÁªúËøûÊé•ÂíåÈÖçÁΩÆ', 'error');
            }
        });
        }); // End getChatHistory callback function
    }

    function handleStreamData(data, loadingMessageId) {
        switch (data.type) {
            case 'start':
                // Remove loading message, start showing actual response
                $("#" + loadingMessageId).remove();
                currentStreamMessageId = 'stream-' + Date.now();
                addMessageToChat("assistant", "", currentStreamMessageId);
                break;
                
            case 'text':
            case 'content':
                // Append text content
                if (currentStreamMessageId) {
                    appendToMessage(currentStreamMessageId, data.content);
                }
                break;
                
            case 'text-delta':
                // Handle streaming text increments
                if (currentStreamMessageId) {
                    appendToMessage(currentStreamMessageId, data.textDelta);
                }
                break;
                
            case 'action_button':
                // Handle action buttons
                if (currentStreamMessageId) {
                    addActionButton(currentStreamMessageId, data);
                }
                break;
                
            case 'tool_call':
                // Show tool call information (only when tool name is valid)
                if (currentStreamMessageId && data.tool_name && data.tool_name !== 'undefined') {
                    // var toolInfo = `üîß ${_("sidebar.messages.toolCalling")}: ${data.tool_name}\n${_("sidebar.messages.parameters")}: ${JSON.stringify(data.arguments, null, 2)}\n`;
                    // appendToMessage(currentStreamMessageId, toolInfo);
                }
                break;
                
            case 'tool_result':
                // Show tool execution result in a separate message bubble
                var toolResultMessageId = 'tool-result-' + Date.now();
                var resultInfo = `‚úÖ ${_("sidebar.messages.toolExecutionSuccess")}\n\n`;
                
                // If there's specific result data, show formatted result
                if (data.result) {
                    try {
                        // Try to parse tool result
                        var toolResult = data.result;
                        if (typeof toolResult === 'string') {
                            try {
                                toolResult = JSON.parse(toolResult);
                            } catch (e) {
                                // If not JSON, use string directly
                            }
                        }
                        
                        // If result contains content array (MCP tool return format)
                        if (toolResult && toolResult.content && Array.isArray(toolResult.content)) {
                            for (var i = 0; i < toolResult.content.length; i++) {
                                var contentItem = toolResult.content[i];
                                if (contentItem.type === 'text' && contentItem.text) {
                                    try {
                                        // Try to parse nested JSON configuration
                                        var configData = JSON.parse(contentItem.text);
                                        resultInfo += '**' + _('sidebar.messages.nodeRedConfigInfo') + '**\n\n```json\n' + JSON.stringify(configData, null, 2) + '\n```\n\n';
                                    } catch (e) {
                                        // If not JSON, show text directly
                                        resultInfo += contentItem.text + '\n\n';
                                    }
                                }
                            }
                        } else {
                            // Other format results, show directly
                            resultInfo += '**' + _('sidebar.messages.result') + '**\n\n```\n' + (typeof toolResult === 'string' ? toolResult : JSON.stringify(toolResult, null, 2)) + '\n```\n\n';
                        }
                    } catch (e) {
                        resultInfo += '**' + _('sidebar.messages.result') + '**\n\n```\n' + data.result + '\n```\n\n';
                    }
                }
                console.log("+++++++++++++++++++++++++++resultInfo",resultInfo)
                
                // Create a separate message bubble for tool result
                addMessageToChat("system", resultInfo, toolResultMessageId);
                break;
                
            case 'error':
                if (currentStreamMessageId) {
                    appendToMessage(currentStreamMessageId, `‚ùå ${_('sidebar.messages.error')}: ${data.message || data.content || data.error}`);
                }
                
                // Check if it's API key authentication failure error
                if (data.code === 'API_AUTH_FAILED' || 
                    (data.message && data.message.includes('APIÂØÜÈí•')) ||
                    (data.content && data.content.includes('APIÂØÜÈí•'))) {
                    
                    // Show specific API key error notification
                    RED.notify(_('sidebar.messages.apiKeyError'), 'error');
                    
                    // Automatically open configuration interface
                    setTimeout(function() {
                        openConfigInterface();
                    }, 1000);
                } else {
                    // Show general error notification
                    RED.notify(data.message || data.content || data.error || _('sidebar.messages.unknownError'), 'error');
                }
                
                // Reset send button loading state and clear abort controller
                setSendButtonLoading(false);
                if (window.currentAbortController) {
                    window.currentAbortController = null;
                }
                break;
                
            case 'done':
            case 'end':
            case 'finish':
                // Streaming response completed, final action marker detection
                if (currentStreamMessageId) {
                    detectAndProcessActionMarkers(currentStreamMessageId);
                    // Save complete chat message
                    var messageElement = $("#" + currentStreamMessageId + " .message-content");
                    var finalContent = messageElement.attr('data-raw-text') || messageElement.text() || "";
                    saveChatMessage("assistant", finalContent);
                }
                currentStreamMessageId = null;
                
                // Reset send button state when response is complete
                setSendButtonLoading(false);
                
                // Clear abort controller
                if (window.currentAbortController) {
                    window.currentAbortController = null;
                }
                break;
        }
    }

    function appendToMessage(messageId, content) {
        var messageElement = $("#" + messageId + " .message-content");
        if (messageElement.length > 0) {
            // Get current text content (not HTML to avoid double-rendering)
            var currentText = messageElement.attr('data-raw-text') || '';
            var newText = currentText + content;
            
            // Store raw text for future appends
            messageElement.attr('data-raw-text', newText);
            
            // Render combined content as markdown
            var renderedContent = renderMarkdown(newText);
            
            messageElement.html(renderedContent);
            
            // Apply syntax highlighting if highlight.js is available
            if (typeof hljs !== 'undefined') {
                messageElement.find('pre code').each(function(i, block) {
                    try {
                        hljs.highlightElement(block);
                    } catch (e) {
                        // Ignore syntax highlighting errors
                    }
                });
            }
            
            // Enhance code block display - ensure execution after syntax highlighting
            setTimeout(function() {
                enhanceCodeBlocks(messageElement);
            }, 100);
            
            // Scroll to bottom
            forceScrollToBottom();
        }
    }

    function getSelectedConfigNodeId() {
        // First find AI assistant node, then get its associated API config node
        var configNodeId = null;
        try {
            // Find AI assistant nodes of make-iot-smart type
            RED.nodes.eachNode(function(node) {
                if (node.type === 'make-iot-smart' && node.apiConfig) {
                    configNodeId = node.apiConfig;
                    return false; // Stop after finding the first one
                }
            });
            
            // If not found through AI assistant node, directly search for api-config node
            if (!configNodeId) {
                RED.nodes.eachConfig(function(configNode) {
                    if (configNode.type === 'api-config') {
                        configNodeId = configNode.id;
                        return false; // Stop after finding the first one
                    }
                });
            }
            
            // If not found, try to create a default config node
            if (!configNodeId) {
                configNodeId = createDefaultApiConfigNode();
            }
            
            // Verify if the node actually exists
            if (configNodeId) {
                var node = RED.nodes.node(configNodeId);
                if (!node) {
                    return null;
                }
            }
            
        } catch (error) {
            // Ignore config node retrieval errors
        }
        return configNodeId;
    }
    // Get JSON data from code block
    function getJsonFromCodeBlock(blockId) {
        try {
            var $codeBlock = $('#' + blockId);
            if (!$codeBlock.length) {
                return null;
            }
            
            // Find code element in code block
            var $code = $codeBlock.find('code');
            if (!$code.length) {
                return null;
            }
            
            // Get code text content
            var codeText = $code.text().trim();
            
            // Try to parse JSON
            var parsedJson = JSON.parse(codeText);
            return {
                jsonString: codeText,
                parsedJson: parsedJson
            };
            
        } catch (e) {
            return null;
        }
    }


    // Fallback copy solution
    function fallbackCopyTextToClipboard(text) {
        var textArea = document.createElement("textarea");
        textArea.value = text;
        textArea.style.position = "fixed";
        textArea.style.left = "-999999px";
        textArea.style.top = "-999999px";
        document.body.appendChild(textArea);
        textArea.focus();
        textArea.select();
        
        try {
            var successful = document.execCommand('copy');
            if (successful) {
                RED.notify("JSON data copied to clipboard", "success");
            } else {
                RED.notify(_("sidebar.messages.copyFailed"), "error");
            }
        } catch (err) {
            RED.notify(_("sidebar.messages.copyFailed"), "error");
        }
        
        document.body.removeChild(textArea);
    }


    // Detect and process action markers - support ACTION_TYPE format
    function detectAndProcessActionMarkers(messageId) {
        var messageElement = $("#" + messageId + " .message-content");
        if (messageElement.length === 0) {
            return;
        }
        
        // First try to enhance code blocks
        enhanceCodeBlocks(messageElement);
        
        // Check if buttons have already been added
        if (messageElement.find('.action-button-container').length > 0) {
            return;
        }
        
        // Find action markers
        var actionMarkers = messageElement.find('.action-marker');
        if (actionMarkers.length > 0) {
            // Process the first action marker
            var firstMarker = actionMarkers.first();
            var markerActionType = firstMarker.data('action-type');
            var jsonContent = decodeURIComponent(firstMarker.data('json-content') || '');
            
            if (markerActionType && jsonContent && markerActionType !== 'EXPLAIN') {
                try {
                    var parsedJson = JSON.parse(jsonContent);
                    
                    var actionData = {
                        type: 'action_button',
                        actionType: markerActionType,
                        toolName: getToolNameForAction(markerActionType),
                        toolArgs: buildToolArgsForAction(markerActionType, parsedJson),
                        jsonContent: JSON.stringify(parsedJson, null, 2),
                        buttonText: getButtonTextForAction(markerActionType),
                        buttonColor: getButtonColorForAction(markerActionType),
                        buttonIcon: getButtonIconForAction(markerActionType),
                        description: getDescriptionForAction(markerActionType)
                    };
                    
                    // Action data construction completed
                    
                    // Add action button
                    addActionButton(messageId, actionData);
                    
                } catch (error) {
                    console.error("Â§ÑÁêÜÂä®‰ΩúÂ§±Ë¥•:", error);
                }
            }
            return;
        }
        
        // If no action markers found, use original text parsing method
        var rawText = messageElement.attr('data-raw-text') || '';
        console.log("‰ΩøÁî®ÊñáÊú¨Ëß£ÊûêÊñπÂºèÔºåÊñáÊú¨ÈïøÂ∫¶:", rawText.length);
        
        // Detect ACTION_TYPE format
        var actionTypePattern = /ACTION_TYPE:\s*(\w+)/gi;
        var jsonBlockPattern = /```json\s*([\s\S]*?)\s*```/gi;
        
        var detectedActionType = null;
        var detectedJsonContent = null;
        
        // Find ACTION_TYPE
        actionTypePattern.lastIndex = 0;
        var actionMatch = actionTypePattern.exec(rawText);
        if (actionMatch) {
            detectedActionType = actionMatch[1].toUpperCase();
        }
        
        // Find JSON configuration
        jsonBlockPattern.lastIndex = 0;
        var jsonMatch = jsonBlockPattern.exec(rawText);
        if (jsonMatch) {
            detectedJsonContent = jsonMatch[1].trim();
        }
        
        // Only add button when there's JSON config and not EXPLAIN type
        if (detectedActionType && detectedJsonContent && detectedActionType !== 'EXPLAIN') {
            try {
                var parsedJson = JSON.parse(detectedJsonContent);
                
                var actionData = {
                    type: 'action_button',
                    actionType: detectedActionType,
                    toolName: getToolNameForAction(detectedActionType),
                    toolArgs: buildToolArgsForAction(detectedActionType, parsedJson),
                    jsonContent: JSON.stringify(parsedJson, null, 2),
                    buttonText: getButtonTextForAction(detectedActionType),
                    buttonColor: getButtonColorForAction(detectedActionType),
                    buttonIcon: getButtonIconForAction(detectedActionType),
                    description: getDescriptionForAction(detectedActionType)
                };
                
                // Action data construction completed
                
                // Add action button
                addActionButton(messageId, actionData);
                
            } catch (error) {
                // Ignore action processing errors
            }
        } else if (detectedActionType === 'EXPLAIN') {
            // For EXPLAIN type, no need to add button, just explanatory content
        }
    }

    // Preprocess function node code in Node-RED flow JSON
    function preprocessNodeRedFunctionCode(content) {
        
        // Find JSON code blocks
        const jsonBlockPattern = /```json\s*([\s\S]*?)\s*```/g;
        
        return content.replace(jsonBlockPattern, function(match, jsonContent) {
            try {
                
                // Try to parse JSON
                const parsedJson = JSON.parse(jsonContent);
                
                // If it's Node-RED flow configuration
                if (parsedJson.nodes && Array.isArray(parsedJson.nodes)) {
                    
                    // Process each node
                    parsedJson.nodes = parsedJson.nodes.map(function(node, index) {
                        if (node.type === 'function' && node.func && typeof node.func === 'string') {
                            
                            // Generate unique ID
                            const codeId = 'func-code-' + Date.now() + '-' + index;
                            
                            // Save original code to global variable
                            if (!window.nodeRedFunctionCodes) {
                                window.nodeRedFunctionCodes = {};
                            }
                            window.nodeRedFunctionCodes[codeId] = {
                                code: node.func,
                                nodeName: node.name || node.id,
                                nodeId: node.id
                            };
                            
                            // Replace func content with simple text and button
                            node.func = 'code <button class="code-view-btn" data-code-id="' + codeId + '" style="' +
                                'background: #f1f5f9; ' +
                                'border: 1px solid #cbd5e1; ' +
                                'border-radius: 4px; ' +
                                'padding: 2px 8px; ' +
                                'font-size: 12px; ' +
                                'color: #475569; ' +
                                'cursor: pointer; ' +
                                'margin-left: 4px; ' +
                                'vertical-align: middle; ' +
                                'transition: all 0.2s;' +
                                '">View Code</button>';
                        }
                        return node;
                    });
                    
                    // Return processed JSON code block
                    return '```json\n' + JSON.stringify(parsedJson, null, 2) + '\n```';
                }
                
                // If not Node-RED flow configuration, return original content
                return match;
                
            } catch (e) {
                return match;
            }
        });
    }

    // Show function code modal
    function showFunctionCodeModal(codeData) {
        
        // Escape node name to prevent HTML injection
        var escapedNodeName = codeData.nodeName.replace(/[<>&"']/g, function(match) {
            var escapeMap = {
                '<': '&lt;',
                '>': '&gt;',
                '&': '&amp;',
                '"': '&quot;',
                "'": '&#39;'
            };
            return escapeMap[match];
        });
        
        var escapedCode = codeData.code.replace(/[<>&"']/g, function(match) {
            var escapeMap = {
                '<': '&lt;',
                '>': '&gt;',
                '&': '&amp;',
                '"': '&quot;',
                "'": '&#39;'
            };
            return escapeMap[match];
        });
        
        // Create modal HTML
        var modalHtml = '<div id="function-code-modal" style="' +
            'position: fixed;' +
            'top: 0;' +
            'left: 0;' +
            'width: 100%;' +
            'height: 100%;' +
            'background: rgba(0,0,0,0.5);' +
            'z-index: 10000;' +
            'display: flex;' +
            'align-items: center;' +
            'justify-content: center;' +
            '">' +
                '<div style="' +
                    'background: white;' +
                    'border-radius: 8px;' +
                    'width: 80%;' +
                    'max-width: 800px;' +
                    'max-height: 80%;' +
                    'display: flex;' +
                    'flex-direction: column;' +
                    'box-shadow: 0 4px 20px rgba(0,0,0,0.3);' +
                    '">' +
                    '<div style="' +
                        'padding: 16px 20px;' +
                        'border-bottom: 1px solid #e5e7eb;' +
                        'display: flex;' +
                        'justify-content: space-between;' +
                        'align-items: center;' +
                        '">' +
                        '<h3 style="margin: 0; color: #374151;">Function Node Code: ' + escapedNodeName + '</h3>' +
                        '<button id="close-code-modal" style="' +
                            'background: none;' +
                            'border: none;' +
                            'font-size: 20px;' +
                            'cursor: pointer;' +
                            'color: #6b7280;' +
                            '">&times;</button>' +
                    '</div>' +
                    '<div style="' +
                        'flex: 1;' +
                        'overflow: auto;' +
                        'padding: 20px;' +
                        '">' +
                        '<pre style="' +
                            'background: #f8fafc;' +
                            'border: 1px solid #e2e8f0;' +
                            'border-radius: 6px;' +
                            'padding: 16px;' +
                            'margin: 0;' +
                            'overflow: auto;' +
                            'font-family: Monaco, Menlo, Ubuntu Mono, monospace;' +
                            'font-size: 14px;' +
                            'line-height: 1.5;' +
                            '"><code class="javascript">' + escapedCode + '</code></pre>' +
                    '</div>' +
                    '<div style="' +
                        'padding: 16px 20px;' +
                        'border-top: 1px solid #e5e7eb;' +
                        'display: flex;' +
                        'justify-content: flex-end;' +
                        'gap: 10px;' +
                        '">' +
                        '<button id="copy-code-btn" style="' +
                            'background: #3b82f6;' +
                            'color: white;' +
                            'border: none;' +
                            'padding: 8px 16px;' +
                            'border-radius: 6px;' +
                            'cursor: pointer;' +
                            '">Copy Code</button>' +
                        '<button id="close-code-modal-btn" style="' +
                            'background: #6b7280;' +
                            'color: white;' +
                            'border: none;' +
                            'padding: 8px 16px;' +
                            'border-radius: 6px;' +
                            'cursor: pointer;' +
                            '">Close</button>' +
                    '</div>' +
                '</div>' +
            '</div>';
        
        // Add to page
        $('body').append(modalHtml);
        
        // Apply syntax highlighting
        if (typeof hljs !== 'undefined') {
            $('#function-code-modal code.javascript').each(function(i, block) {
                try {
                    hljs.highlightElement(block);
                } catch (e) {
                    // Ignore syntax highlighting errors
                }
            });
        }
        
        // Bind close events
        $('#close-code-modal, #close-code-modal-btn').click(function() {
            $('#function-code-modal').remove();
        });
        
        // Bind copy events
        $('#copy-code-btn').click(function() {
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(codeData.code).then(function() {
                    $('#copy-code-btn').text('Copied').css('background', '#10b981');
                    setTimeout(function() {
                        $('#copy-code-btn').text('Copy Code').css('background', '#3b82f6');
                    }, 2000);
                }).catch(function(err) {
                    // Ignore copy errors
                });
            } else {
                // Fallback solution
                var textArea = document.createElement("textarea");
                textArea.value = codeData.code;
                document.body.appendChild(textArea);
                textArea.select();
                try {
                    document.execCommand('copy');
                    $('#copy-code-btn').text('Copied').css('background', '#10b981');
                    setTimeout(function() {
                        $('#copy-code-btn').text('Copy Code').css('background', '#3b82f6');
                    }, 2000);
                } catch (err) {
                    // Ignore copy errors
                }
                document.body.removeChild(textArea);
            }
        });
        
        // Click background to close
        $('#function-code-modal').click(function(e) {
            if (e.target === this) {
                $(this).remove();
            }
        });
    }
    // Add dropdown menu event handling for more options button
    $(document).on('click', '.code-more-btn', function(e) {
        e.preventDefault();
        e.stopPropagation();
        
        var blockId = $(this).data('block-id');
        var $button = $(this);
        var existingMenu = $('.code-dropdown-menu');
        
        // If menu already exists, remove it first
        if (existingMenu.length > 0) {
            existingMenu.remove();
            return;
        }
        
        // Get current flow information
        var currentFlowName = 'No Flow Selected';
        try {
            var activeWorkspace = RED.workspaces.active();
            if (activeWorkspace) {
                var workspace = RED.nodes.workspace(activeWorkspace);
                currentFlowName = workspace ? workspace.label : 'Current Flow';
            }
        } catch (error) {
            // Ignore current flow retrieval errors
        }
        
        // Add CSS reset styles to ensure menu items have no default spacing
        if (!document.getElementById('code-dropdown-reset-styles')) {
            var resetStyle = document.createElement('style');
            resetStyle.id = 'code-dropdown-reset-styles';
            resetStyle.textContent = `
                .code-dropdown-menu {
                    box-sizing: border-box !important;
                }
                .code-dropdown-menu .menu-item {
                    margin: 0 !important;
                    padding: 0px 16px !important;
                    border: none !important;
                    line-height: 1 !important;
                    height: 0px !important;
                    box-sizing: border-box !important;
                    display: flex !important;
                    align-items: center !important;
                }
                .code-dropdown-menu .menu-item:first-child {
                    border-top-left-radius: 6px;
                    border-top-right-radius: 6px;
                }
                .code-dropdown-menu .menu-item:last-child {
                    border-bottom-left-radius: 6px;
                    border-bottom-right-radius: 6px;
                }
            `;
            document.head.appendChild(resetStyle);
        }
        
        // Create dropdown menu
        var menuHtml = `
            <div class="code-dropdown-menu" style="
                position: absolute;
                top: 100%;
                right: 0;
                background: white;
                border: 1px solid #d1d5db;
                border-radius: 6px;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
                z-index: 1000;
                min-width: 140px;
                font-size: 13px;
                padding: 0;
                margin-top: 4px;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                line-height: 1;
            ">
                <div class="menu-item" data-action="copy" data-block-id="${blockId}" style="
                    padding: 10px 16px;
                    cursor: pointer;
                    display: flex;
                    align-items: center;
                    gap: 10px;
                    color: #374151;
                    transition: background-color 0.1s;
                    font-weight: 400;
                    margin: 0;
                    border: none;
                    line-height: 1;
                    height: 36px;
                    box-sizing: border-box;
                " onmouseover="this.style.backgroundColor='#f3f4f6'" onmouseout="this.style.backgroundColor='transparent'">
                    <i class="fa fa-copy" style="font-size: 12px; width: 14px; color: #6b7280;"></i>
                    <span>Copy</span>
                </div>
                <div class="menu-item" data-action="create-new" data-block-id="${blockId}" style="
                    padding: 10px 16px;
                    cursor: pointer;
                    display: flex;
                    align-items: center;
                    gap: 10px;
                    color: #374151;
                    transition: background-color 0.1s;
                    font-weight: 400;
                    margin: 0;
                    border: none;
                    line-height: 1;
                    height: 36px;
                    box-sizing: border-box;
                " onmouseover="this.style.backgroundColor='#f3f4f6'" onmouseout="this.style.backgroundColor='transparent'">
                    <i class="fa fa-plus" style="font-size: 12px; width: 14px; color: #6b7280;"></i>
                    <span>Create in New Flow</span>
                </div>
            </div>
        `;
        
        // Add menu to button's parent container
        $button.parent().append(menuHtml);
        
        // Click elsewhere to close menu
        $(document).on('click.code-dropdown', function(e) {
            if (!$(e.target).closest('.code-dropdown-menu, .code-more-btn').length) {
                $('.code-dropdown-menu').remove();
                $(document).off('click.code-dropdown');
            }
        });
    });
    // Handle dropdown menu item clicks
    $(document).on('click', '.menu-item', function(e) {
        e.preventDefault();
        
        var action = $(this).data('action');
        var blockId = $(this).data('block-id');
        
        // Handle menu item click
        
        // Close menu
        $('.code-dropdown-menu').remove();
        $(document).off('click.code-dropdown');
        
        // Get JSON data from code block
        var jsonData = getJsonFromCodeBlock(blockId);
        if (!jsonData) {
            RED.notify("Unable to get JSON data", "error");
            return;
        }
        
        // Handle copy operation
        if (action === 'copy') {
            try {
                var formattedJson = JSON.stringify(jsonData.parsedJson, null, 2);
                
                if (navigator.clipboard && navigator.clipboard.writeText) {
                    navigator.clipboard.writeText(formattedJson).then(function() {
                        RED.notify("JSON data copied to clipboard", "success");
                    }).catch(function(err) {
                        fallbackCopyTextToClipboard(formattedJson);
                    });
                } else {
                    fallbackCopyTextToClipboard(formattedJson);
                }
            } catch (e) {
                RED.notify("JSON format error, unable to copy", "error");
            }
            return;
        }
        
        // Handle create operation
        if (action === 'create-new' || action === 'create-current') {
            // Get current selected flow information
            var selectedFlow = null;
            var nodeId = null;
            
            try {
                // Get configuration node ID
                var configNodes = [];
                RED.nodes.eachConfig(function(configNode) {
                    if (configNode.type === 'api-config') {
                        configNodes.push(configNode);
                    }
                });
                
                if (configNodes.length > 0) {
                    nodeId = configNodes[0].id;
                }
                
                // Get current flow information
                if (action === 'create-current') {
                    var activeWorkspace = RED.workspaces.active();
                    if (activeWorkspace) {
                        selectedFlow = {
                            id: activeWorkspace,
                            label: RED.nodes.workspace(activeWorkspace).label || 'Current Flow'
                        };
                    }
                }
            } catch (error) {
                // Ignore flow information retrieval errors
            }
            
            if (!nodeId) {
                RED.notify("API configuration node not found", "error");
                return;
            }
            
            // Build tool parameters
            var toolArgs = {
                flowJson: jsonData.jsonString, // Use original JSON string
                description: jsonData.parsedJson.description || ''
            };
            
            // Set label based on operation type
            if (action === 'create-current' && selectedFlow && selectedFlow.id) {
                // When creating in current flow, don't set label, let backend keep original label
                toolArgs.flowId = selectedFlow.id;
                // Only use label when explicitly specified in JSON
                if (jsonData.parsedJson.label) {
                    toolArgs.label = jsonData.parsedJson.label;
                }
            } else {
                // Use default label when creating new flow
                toolArgs.label = jsonData.parsedJson.label || 'New Flow';
            }
            
            // Prepare to execute create-flow tool
            
            // Show executing message
            var executingMsg = action === 'create-new' ? 
                "üîÑ Creating new flow..." : 
                "üîÑ Adding to current flow...";
            addMessageToChat("system", executingMsg);
            
            // Call MCP tool
            fetch('/ai-sidebar/execute-tool', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    toolName: 'create-flow',
                    parameters: toolArgs,
                    nodeId: nodeId,
                    selectedFlow: selectedFlow
                })
            })
            .then(response => response.json())
            .then(data => {
                
                if (data.success) {
                    // Show success message
                    var successMsg = action === 'create-new' ? 
                        "‚úÖ New flow created successfully!" : 
                        "‚úÖ Flow added to current workspace!";
                    addMessageToChat("system", successMsg);
                    
                    // Refresh logic removed - using apply button refresh only
                } else {
                    // Execution failed
                    addMessageToChat("error", "‚ùå " + _("sidebar.messages.toolExecutionFailed") + ": " + data.error);
                }
            })
            .catch(error => {
                addMessageToChat("error", "‚ùå " + _("sidebar.messages.networkError") + ": " + error.message);
            });
        }
    });
  
    function fallbackCopyTextToClipboard(text) {
        var textArea = document.createElement("textarea");
        textArea.value = text;
        
        // Avoid scrolling to bottom
        textArea.style.top = "0";
        textArea.style.left = "0";
        textArea.style.position = "fixed";
        textArea.style.opacity = "0";
        
        document.body.appendChild(textArea);
        textArea.focus();
        textArea.select();
        
        try {
            var successful = document.execCommand('copy');
            if (successful) {
                RED.notify(_("sidebar.messages.jsonCopied"), "success");
            } else {
                RED.notify(_("sidebar.messages.copyFailed"), "error");
            }
        } catch (err) {
            RED.notify(_("sidebar.messages.copyFailed"), "error");
        }
        
        document.body.removeChild(textArea);
    }
    // Helper function to reset button state
    function resetButton($button) {
        $button.prop('disabled', false)
            .css('background', '#dc3545')
            .html('<i class="fa fa-exclamation" style="font-size: 9px;"></i> Failed');
        
        // Restore button after 3 seconds
        setTimeout(() => {
            $button.css('background', '#28a745')
                   .html('<i class="fa fa-check" style="font-size: 9px;"></i> Apply');
        }, 3000);
    }
    // Add code block toolbar event handling
    $(document).on('click', '.code-collapse-btn', function(e) {
        e.preventDefault();
        
        var blockId = $(this).data('block-id');
        var $pre = $('#' + blockId);
        var $code = $pre.find('code');
        var $icon = $(this).find('i');
        
        if ($code.is(':visible')) {
            // Collapse
            $code.slideUp(200);
            $icon.removeClass('fa-chevron-down').addClass('fa-chevron-right');
            $pre.css('height', '32px');
        } else {
            // Expand
            $code.slideDown(200);
            $icon.removeClass('fa-chevron-right').addClass('fa-chevron-down');
            $pre.css('height', 'auto');
        }
    });

    // Code block run button event handling
    $(document).on('click', '.code-run-btn', function(e) {
        e.preventDefault();
        
        var $button = $(this);
        var blockId = $button.data('block-id');
        var jsonContent = $button.data('json-content');
        
        // Code block run button clicked
        
        if (!jsonContent) {
            RED.notify(_("sidebar.messages.validJsonNotFound"), 'error');
            return;
        }
        
        // Get configuration node ID
        var nodeId = getSelectedConfigNodeId();
        if (!nodeId) {
            RED.notify(_("sidebar.messages.configNodeNotFound"), 'error');
            return;
        }
        
        // Get currently selected flow
        var selectedFlow = null;
        try {
            var activeWorkspace = RED.workspaces.active();
            if (activeWorkspace) {
                selectedFlow = {
                    id: activeWorkspace,
                    label: RED.nodes.workspace(activeWorkspace).label
                };
            }
        } catch (error) {
            // Ignore current flow retrieval errors
        }
        
        // Build tool parameters
        var toolArgs = {
            flowJson: JSON.stringify(jsonContent),
            label: jsonContent.label || 'New Flow',
            description: jsonContent.description || ''
        };
        
        // If there's a selected flow, create in current flow
        if (selectedFlow && selectedFlow.id) {
            toolArgs.flowId = selectedFlow.id;
        }
        
        // Prepare to execute create-flow tool
        
        // Update button state
        $button.prop('disabled', true)
               .html('<i class="fa fa-spinner fa-spin" style="font-size: 9px;"></i> Running...')
               .css({
                   'background': '#6c757d',
                   'cursor': 'not-allowed'
               });
        
        // Call MCP tool
        fetch('/ai-sidebar/execute-tool', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                toolName: 'create-flow',
                parameters: toolArgs,
                nodeId: nodeId,
                selectedFlow: selectedFlow
            })
        })
        .then(response => response.json())
        .then(data => {
            
            if (data.success) {
                // Successful execution
                $button.css({
                        'background': '#28a745',
                        'cursor': 'default'
                    })
                    .html('<i class="fa fa-check" style="font-size: 9px;"></i> Completed')
                    .prop('disabled', true);
                
                // Show success message
                addMessageToChat("system", "‚úÖ " + _("sidebar.messages.flowCreationSuccess"));
                
                // Refresh logic removed - using apply button refresh only
            } else {
                // Execution failed
                $button.prop('disabled', false)
                    .css('background', '#dc3545')
                    .html('<i class="fa fa-exclamation" style="font-size: 9px;"></i> Failed');
                
                addMessageToChat("error", "‚ùå " + _("sidebar.messages.toolExecutionFailed") + ": " + data.error);
                
                // Restore button after 3 seconds
                setTimeout(() => {
                    $button.css('background', '#28a745')
                           .html('<i class="fa fa-play" style="font-size: 9px;"></i> Apply');
                }, 3000);
            }
        })
        .catch(error => {
            
            $button.prop('disabled', false)
                .css('background', '#dc3545')
                .html('<i class="fa fa-exclamation" style="font-size: 9px;"></i> Error');
            
            addMessageToChat("error", "‚ùå " + _("sidebar.messages.networkError") + ": " + error.message);
            
            // Restore button after 3 seconds
            setTimeout(() => {
                $button.css('background', '#28a745')
                       .html('<i class="fa fa-play" style="font-size: 9px;"></i> Apply');
            }, 3000);
        });
    });
    // Add code view functionality event handling
    $(document).on('click', '.code-view-btn', function(e) {
        e.preventDefault();
        
        var codeId = $(this).attr('data-code-id');
        
        if (codeId && window.nodeRedFunctionCodes) {
            var codeData = window.nodeRedFunctionCodes[codeId];
            
            if (codeData) {
                showFunctionCodeModal(codeData);
            }
        }
    });

    // Add action type button event handling
    $(document).on('click', '.action-type-btn', function(e) {
        e.preventDefault();
        
        var buttonActionType = $(this).attr('data-action-type');
        var messageContainer = $(this).closest('.augment-message-container');
        
        // Click action button
        
        // Find JSON content in message
        var jsonContent = extractJSONFromMessage(messageContainer);
        
        if (jsonContent) {
            try {
                var parsedJson = JSON.parse(jsonContent);
                
                // Build action data
                var actionData = {
                    type: 'action_button',
                    actionType: buttonActionType,
                    toolName: getToolNameForAction(buttonActionType),
                    toolArgs: buildToolArgsForAction(buttonActionType, parsedJson),
                    jsonContent: JSON.stringify(parsedJson, null, 2),
                    buttonText: getButtonTextForAction(buttonActionType),
                    buttonColor: getButtonColorForAction(buttonActionType),
                    buttonIcon: getButtonIconForAction(buttonActionType),
                    description: getDescriptionForAction(buttonActionType)
                };
                
                // Action data construction completed
                
                // Replace action button with Apply button
                var messageId = messageContainer.attr('id');
                if (messageId) {
                    // Remove original action button
                    $(this).parent().remove();
                    
                    // Add Apply button
                    addActionButton(messageId, actionData);
                }
                
            } catch (error) {
                RED.notify(_("sidebar.messages.actionProcessingFailed") + ': ' + error.message, 'error');
            }
        } else {
            RED.notify(_("sidebar.messages.validConfigNotFound"), 'warning');
        }
    });

    // Extract JSON content from message
    function extractJSONFromMessage(messageContainer) {
        var jsonContent = '';
        
        // Find JSON in code blocks
        messageContainer.find('pre code').each(function() {
            var codeText = $(this).text().trim();
            if (codeText.startsWith('{') && codeText.endsWith('}')) {
                try {
                    JSON.parse(codeText);
                    jsonContent = codeText;
                    return false; // Stop when first valid JSON is found
                } catch (e) {
                    // Continue searching
                }
            }
        });
        
        return jsonContent;
    }

    // Get tool name for action
    function getToolNameForAction(actionType) {
        const toolMap = {
            'CREATE': 'create-flow',
            'MODIFY': 'update-flow', 
            'DELETE': 'delete-flow',
            'INSTALL': 'install-nodes',
            'RESTART': 'restart-nodered',
            'CONFIG': 'update-config',
            'DEPLOY': 'deploy-flows',
            'BACKUP': 'backup-flows',
            'RESTORE': 'restore-flows'
        };
        return toolMap[actionType] || 'unknown-action';
    }

    // Get button text for action
    function getButtonTextForAction(actionType) {
        const textMap = {
            'CREATE': 'Create Flow',
            'MODIFY': 'Modify Flow',
            'DELETE': 'Delete Flow', 
            'INSTALL': 'Install Nodes',
            'RESTART': 'Restart Node-RED',
            'CONFIG': 'Update Config',
            'DEPLOY': 'Deploy Changes',
            'BACKUP': 'Backup Flows',
            'RESTORE': 'Restore Flows'
        };
        return textMap[actionType] || 'Execute';
    }

    // Get button color for action
    function getButtonColorForAction(actionType) {
        const colorMap = {
            'CREATE': '#10b981',
            'MODIFY': '#3b82f6',
            'DELETE': '#ef4444',
            'INSTALL': '#8b5cf6',
            'RESTART': '#f59e0b',
            'CONFIG': '#6b7280',
            'DEPLOY': '#059669',
            'BACKUP': '#0891b2',
            'RESTORE': '#7c3aed'
        };
        return colorMap[actionType] || '#6b7280';
    }

    // Get button icon for action
    function getButtonIconForAction(actionType) {
        const iconMap = {
            'CREATE': 'fa-plus',
            'MODIFY': 'fa-edit',
            'DELETE': 'fa-trash',
            'INSTALL': 'fa-download',
            'RESTART': 'fa-refresh',
            'CONFIG': 'fa-cog',
            'DEPLOY': 'fa-rocket',
            'BACKUP': 'fa-save',
            'RESTORE': 'fa-upload'
        };
        return iconMap[actionType] || 'fa-play';
    }

    // Get description for action
    function getDescriptionForAction(actionType) {
        const descMap = {
            'CREATE': 'Click to create new flow',
            'MODIFY': 'Click to modify existing flow',
            'DELETE': 'Click to delete selected flow',
            'INSTALL': 'Click to install Node-RED node packages',
            'RESTART': 'Click to restart Node-RED service',
            'CONFIG': 'Click to update Node-RED configuration',
            'DEPLOY': 'Click to deploy current changes',
            'BACKUP': 'Click to backup current flows',
            'RESTORE': 'Click to restore flow backup'
        };
        return descMap[actionType] || 'Click to execute operation';
    }

    // Build tool parameters for action
    function buildToolArgsForAction(actionTypeParam, parsedJson) {
        switch (actionTypeParam) {
            case 'CREATE':
            case 'MODIFY':
                return {
                    flowJson: JSON.stringify(parsedJson),
                    label: parsedJson.label || 'New Flow',
                    description: parsedJson.description || ''
                };
            case 'INSTALL':
                return {
                    packages: parsedJson.packages || [],
                    description: parsedJson.description || ''
                };
            case 'CONFIG':
                return {
                    settings: parsedJson.settings || {},
                    description: parsedJson.description || ''
                };
            case 'RESTART':
                return {
                    reason: parsedJson.reason || 'User requested restart',
                    backup: parsedJson.backup !== false
                };
            case 'BACKUP':
                return {
                    name: parsedJson.name || `backup_${new Date().toISOString().slice(0,10)}`,
                    description: parsedJson.description || ''
                };
            case 'RESTORE':
                return {
                    backupName: parsedJson.backupName || '',
                    description: parsedJson.description || ''
                };
            default:
                return parsedJson;
        }
    }

    function createDefaultApiConfigNode() {
        try {
            // Check if api-config node type is registered
            var apiConfigNodeType = RED.nodes.getType("api-config");
            if (!apiConfigNodeType) {
                return null;
            }
            
            // Create default api-config node
            var defaultConfigNode = {
                id: RED.nodes.id(),
                _def: apiConfigNodeType,
                type: "api-config",
                hasUsers: false,
                users: [],
                name: _("sidebar.labels.defaultAIConfig"),
                label: function() { return this.name || _("sidebar.labels.defaultAIConfig"); },
                provider: "openai",
                model: "gpt-4o-mini",
                temperature: 0.1,
                maxTokens: 2000,
                useDifferentModels: false,
                planningModel: "",
                executionModel: "",
                credentials: {
                    apiKey: _("sidebar.labels.pleaseConfigureApiKey") // Temporary placeholder
                }
            };
            
            // Add to Node-RED node collection
            RED.nodes.add(defaultConfigNode);
            RED.nodes.dirty(true);
            
            // Default api-config node created
            
            // Deploy immediately to ensure node is saved to backend
            RED.deploy.setDeployInflight(false);
            RED.nodes.dirty(true);
            
            // Prompt user to configure and deploy
            setTimeout(function() {
                RED.notify(_("sidebar.messages.defaultConfigCreated"), "info");
                RED.editor.editConfig("", "api-config", defaultConfigNode.id);
            }, 1000);
            
            return defaultConfigNode.id;
        } catch (error) {
            return null;
        }
    }

    // Function to automatically open configuration interface
    function openConfigInterface() {
        
        try {
            var apiConfigNodes = [];
            RED.nodes.eachConfig(function(configNode) {
                if (configNode.type === 'api-config') {
                    apiConfigNodes.push(configNode);
                }
            });
            
            if (apiConfigNodes.length > 0) {
                RED.editor.editConfig("", "api-config", apiConfigNodes[0].id);
            } else {
                var newNodeId = createDefaultApiConfigNode();
                if (newNodeId) {
                    // createDefaultApiConfigNode will automatically open edit interface
                } else {
                    // If creation fails, directly open new configuration dialog
                    RED.editor.editConfig("", "api-config");
                }
            }
        } catch (error) {
            RED.notify(_("sidebar.messages.errorOpeningConfig") + ": " + error.message, "error");
        }
    }

    // Global variable to store current session ID
    var currentSessionId = null;
    
    // Get or generate current session ID
    function getCurrentSessionId() {
        if (!currentSessionId) {
            // Try to get from localStorage
            currentSessionId = localStorage.getItem('node-red-ai-session-id');
            if (!currentSessionId) {
                // Generate new session ID
                currentSessionId = 'session-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
                localStorage.setItem('node-red-ai-session-id', currentSessionId);
            }
        }
        return currentSessionId;
    }
    
    function getChatHistory(callback) {
        // First try to get history from SQLite database via backend API
        var sessionId = getCurrentSessionId();
        
        $.ajax({
            url: '/ai-sidebar/history/' + sessionId,
            method: 'GET',
            data: { limit: 20 },
            success: function(response) {
                var history = [];
                
                if (response.history && response.history.length > 0) {
                    // Process history from database
                    history = response.history.map(function(item) {
                        var timestamp = new Date(item.timestamp).toLocaleString();
                        return {
                            role: item.role,
                            content: item.content,
                            timestamp: timestamp,
                            preview: item.content.length > 30 ? item.content.substring(0, 30) + '...' : item.content
                        };
                    });
                }
                
                // If no history in database, get current session messages from DOM
                if (history.length === 0) {
                    console.log(_("sidebar.messages.noHistoryInDatabase"));
                    $("#augment-chat-messages .augment-message-container").each(function() {
                        var role = $(this).hasClass("user-message") ? "user" : "assistant";
                        var content = $(this).find(".message-content").text().trim();
                        var timestamp = $(this).find(".message-timestamp").text() || new Date().toLocaleTimeString();
                        if (content && content !== "ü§ñ Thinking...") {
                            history.push({
                                role: role,
                                content: content,
                                timestamp: timestamp,
                                preview: content.length > 30 ? content.substring(0, 30) + '...' : content
                            });
                        }
                    });
                }
                
                if (callback) callback(history.slice(-20));
            },
            error: function(xhr, status, error) {
                // Get current session messages from DOM as fallback when error occurs
                var history = [];
                $("#augment-chat-messages .augment-message-container").each(function() {
                    var role = $(this).hasClass("user-message") ? "user" : "assistant";
                    var content = $(this).find(".message-content").text().trim();
                    var timestamp = $(this).find(".message-timestamp").text() || new Date().toLocaleTimeString();
                    if (content && content !== "ü§ñ Thinking...") {
                        history.push({
                            role: role,
                            content: content,
                            timestamp: timestamp,
                            preview: content.length > 30 ? content.substring(0, 30) + '...' : content
                        });
                    }
                });
                if (callback) callback(history.slice(-20));
            }
        });
    }

    // Chat history dropdown menu functionality
    function initChatHistoryDropdown() {
        
        // Click dropdown button
        $(document).on('click', '#chat-history-dropdown-btn', function(e) {
            e.preventDefault();
            e.stopPropagation();
            
            var $menu = $('#chat-history-dropdown-menu');
            var isVisible = $menu.is(':visible');
            
            if (isVisible) {
                $menu.hide();
                $(this).find('.fa-chevron-down, .fa-chevron-up').removeClass('fa-chevron-up').addClass('fa-chevron-down');
            } else {
                // Update history content
                updateChatHistoryMenu();
                $menu.show();
                $(this).find('.fa-chevron-down').removeClass('fa-chevron-down').addClass('fa-chevron-up');
            }
        });
        
        // Click elsewhere to close menu
        $(document).on('click', function(e) {
            if (!$(e.target).closest('.chat-history-dropdown-container').length) {
                $('#chat-history-dropdown-menu').hide();
                $('#chat-history-dropdown-btn .fa-chevron-up').removeClass('fa-chevron-up').addClass('fa-chevron-down');
            }
        });
        
        // Click history item
        $(document).on('click', '.chat-history-item', function(e) {
            e.preventDefault();
            var sessionId = $(this).data('session-id');
            if (sessionId) {
                // Switch to selected session
                switchToSession(sessionId);
                // Close dropdown menu
                $('#chat-history-dropdown-menu').hide();
                $('#chat-history-dropdown-btn .fa-chevron-up').removeClass('fa-chevron-up').addClass('fa-chevron-down');
            }
        });
    }
    
    // Update chat history menu content
    function updateChatHistoryMenu() {
        var $menu = $('#chat-history-dropdown-menu');
        
        // Show loading state
        $menu.html(`
            <div class="chat-history-loading" style="
                padding: 16px;
                text-align: center;
                color: #6b7280;
                font-size: 12px;
            " >Loading session history...</div>
        `);
        
        // Get session list
        $.ajax({
            url: '/ai-sidebar/sessions',
            method: 'GET',
            data: { limit: 20 },
            success: function(response) {
                
                if (!response.sessions || response.sessions.length === 0) {
                    $menu.html(`
                        <div class="chat-history-empty" style="
                            padding: 16px;
                            text-align: center;
                            color: #9ca3af;
                            font-size: 12px;
                        ">${_("sidebar.labels.noSessionHistory")}</div>
                    `);
                    return;
                }
                
                var menuHtml = '';
                
                // Add new session button at the top
                menuHtml += `
                    <div class="chat-history-section" style="
                        padding: 8px;
                        border-bottom: 1px solid #f3f4f6;
                    ">
                        <button onclick="createNewSession()" style="
                            width: 100%;
                            padding: 8px 12px;
                            background: #10b981;
                            color: white;
                            border: none;
                            border-radius: 6px;
                            font-size: 12px;
                            font-weight: 500;
                            cursor: pointer;
                            transition: background-color 0.1s;
                            display: flex;
                            align-items: center;
                            justify-content: center;
                            gap: 6px;
                        " onmouseover="this.style.backgroundColor='#059669'" onmouseout="this.style.backgroundColor='#10b981'">
                            <i class="fa fa-plus" style="font-size: 10px;"></i>
                            ${_('sidebar.labels.newSession')}
                        </button>
                    </div>
                `;
                
                // Show session list
                var sessions = response.sessions.slice(0, 15); // Show recent 15 sessions
            
                if (sessions.length > 0) {
                    menuHtml += `
                        <div class="chat-history-section" style="
                            padding: 8px 0;
                            border-bottom: 1px solid #f3f4f6;
                        ">
                            <div class="chat-history-section-title" style="
                                padding: 4px 12px;
                                font-size: 11px;
                                font-weight: 600;
                                color: #6b7280;
                                text-transform: uppercase;
                                letter-spacing: 0.5px;
                            ">${_('sidebar.labels.historySessions')}</div>
                    `;
                    
                    sessions.forEach(function(session, index) {
                        // Use first user message as title, or default title if none
                        var sessionTitle = session.first_user_message 
                            ? (session.first_user_message.length > 30 
                                ? session.first_user_message.substring(0, 30) + '...' 
                                : session.first_user_message)
                            : (session.title || `${_("sidebar.labels.session")} ${session.id.substring(0, 8)}`);
                        var lastMessageTime = session.last_message_time ? new Date(session.last_message_time).toLocaleString() : _("sidebar.labels.unknownTime");
                        var messageCount = session.message_count || 0;
                        var scenarioIcon = session.scenario === 'learning' ? 'üìö' : (session.scenario === 'solution' ? 'üîß' : 'üí°');
                        
                        menuHtml += `
                            <div class="chat-history-item" data-session-id="${session.id}" style="
                                padding: 8px 12px;
                                cursor: pointer;
                                border-bottom: ${index < sessions.length - 1 ? '1px solid #f9fafb' : 'none'};
                                transition: background-color 0.1s;
                                min-width: 0;
                            " onmouseover="this.style.backgroundColor='#f9fafb'" onmouseout="this.style.backgroundColor='transparent'">
                                <div style="
                                    display: flex;
                                    align-items: center;
                                    gap: 6px;
                                    margin-bottom: 4px;
                                ">
                                    <span style="font-size: 10px;">${scenarioIcon}</span>
                                    <span style="
                                        font-size: 12px;
                                        font-weight: 600;
                                        color: #374151;
                                        flex: 1;
                                        white-space: nowrap;
                                        overflow: hidden;
                                        text-overflow: ellipsis;
                                    ">${sessionTitle}</span>
                                    <span style="
                                        font-size: 9px;
                                        color: #9ca3af;
                                        background: #f3f4f6;
                                        padding: 2px 6px;
                                        border-radius: 10px;
                                    ">${messageCount} ${_("sidebar.labels.msgs")}</span>
                                </div>
                                <div style="
                                    font-size: 10px;
                                    color: #6b7280;
                                    padding-left: 16px;
                                ">${lastMessageTime}</div>
                            </div>
                        `;
                    });
                    
                    menuHtml += '</div>';
                }
            
            // Add clear history button
            menuHtml += `
                <div class="chat-history-actions" style="
                    padding: 8px;
                    border-top: 1px solid #f3f4f6;
                    background: #f9fafb;
                ">
                    <button onclick="clearChatHistory()" style="
                        width: 100%;
                        padding: 6px 12px;
                        background: #ef4444;
                        color: white;
                        border: none;
                        border-radius: 4px;
                        font-size: 11px;
                        cursor: pointer;
                        transition: background-color 0.1s;
                    " onmouseover="this.style.backgroundColor='#dc2626'" onmouseout="this.style.backgroundColor='#ef4444'">${_('sidebar.labels.clearHistory')}</button>
                </div>
            `;
            
                $menu.html(menuHtml);
            },
            error: function(xhr, status, error) {
                $menu.html(`
                    <div class="chat-history-error" style="
                        padding: 16px;
                        text-align: center;
                        color: #ef4444;
                        font-size: 12px;
                    " >Failed to load session, please retry</div>
                `);
            }
        });

    }
    
    // Switch to specified session
    function switchToSession(sessionId) {
        
        // Update current session ID
        currentSessionId = sessionId;
        localStorage.setItem('node-red-ai-session-id', sessionId);
        
        // Get conversation history for this session
        $.ajax({
            url: '/ai-sidebar/history/' + sessionId,
            method: 'GET',
            data: { limit: 50 },
            success: function(response) {
                
                // Clear current chat area
                $('#augment-chat-messages').empty();
                
                if (response.history && response.history.length > 0) {
                    // Add system prompt message
                    addMessageToChat('system', `üìã ${_('sidebar.labels.switchedToSession')}: ${sessionId.substring(0, 8)}`);
                    
                    // Redisplay historical conversations in chronological order (oldest first)
                    response.history.forEach(function(msg, index) {
                        var messageId = 'session-' + Date.now() + '-' + index;
                        addMessageToChat(msg.role, msg.content, messageId);
                    });
                    
                    // Session history loaded
                } else {
                    // Add system prompt message
                    addMessageToChat('system', `üìã ${_('sidebar.labels.switchedToNewSession')}: ${sessionId.substring(0, 8)}`);
                }
                
                // Scroll to bottom
                setTimeout(function() {
                    forceScrollToBottom();
                }, 100);
            },
            error: function(xhr, status, error) {
                // Switch session ID even if failed
                $('#augment-chat-messages').empty();
                addMessageToChat('system', `‚ö†Ô∏è ${_('sidebar.labels.switchedToSessionFailed')}: ${sessionId.substring(0, 8)}`);
            }
        });
    }
    
    // Echo and recall chat history
    function recallChatHistory(selectedContent) {
        
        // Get complete chat history
        getChatHistory(function(history) {
            if (history.length === 0) {
                // If no history, just fill selected content into input box
                $('#augment-input').val(selectedContent).focus();
                return;
            }
            
            // Clear current chat area
            $('#augment-chat-messages').empty();
            
            // Add system prompt message
            addMessageToChat('system', 'üìã ' + _("sidebar.labels.chatHistoryRecalled"));
            
            // Redisplay historical conversations
            history.forEach(function(msg, index) {
                var messageId = 'recalled-' + Date.now() + '-' + index;
                addMessageToChat(msg.role, msg.content, messageId);
            });
            
            // Fill selected content into input box
            $('#augment-input').val(selectedContent).focus();
            
            // Scroll to bottom
            setTimeout(function() {
                forceScrollToBottom();
            }, 100);
            
            // console.log('Chat history successfully recalled, total', history.length, 'records');
        });
    }
    
    // Clear chat history
    function clearChatHistory() {
        // ÂàõÂª∫ÁæéËßÇÁöÑÁ°ÆËÆ§Ê®°ÊÄÅÊ°Ü
        const modalHtml = `
            <div id="clear-history-modal" style="
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.5);
                display: flex;
                justify-content: center;
                align-items: center;
                z-index: 10000;
                backdrop-filter: blur(4px);
            ">
                <div style="
                    background: white;
                    border-radius: 12px;
                    padding: 24px;
                    max-width: 400px;
                    width: 90%;
                    box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
                    animation: modalSlideIn 0.3s ease-out;
                ">
                    <div style="
                        display: flex;
                        align-items: center;
                        margin-bottom: 16px;
                    ">
                        <div style="
                            width: 48px;
                            height: 48px;
                            background: #fee2e2;
                            border-radius: 50%;
                            display: flex;
                            align-items: center;
                            justify-content: center;
                            margin-right: 16px;
                        ">
                            <i class="fa fa-exclamation-triangle" style="
                                color: #dc2626;
                                font-size: 20px;
                            "></i>
                        </div>
                        <div>
                            <h3 style="
                                margin: 0;
                                font-size: 18px;
                                font-weight: 600;
                                color: #111827;
                            ">${_('sidebar.confirmations.clearAllHistory.title') || 'Clear All History'}</h3>
                        </div>
                    </div>
                    <p style="
                        margin: 0 0 24px 0;
                        color: #6b7280;
                        font-size: 14px;
                        line-height: 1.5;
                    ">${_('sidebar.confirmations.clearAllHistory.message') || 'This action will permanently delete all chat sessions and cannot be undone. Are you sure you want to continue?'}</p>
                    <div style="
                        display: flex;
                        gap: 12px;
                        justify-content: flex-end;
                    ">
                        <button id="cancel-clear-history" style="
                            padding: 8px 16px;
                            background: #f3f4f6;
                            color: #374151;
                            border: none;
                            border-radius: 6px;
                            font-size: 14px;
                            font-weight: 500;
                            cursor: pointer;
                            transition: all 0.2s;
                        " onmouseover="this.style.backgroundColor='#e5e7eb'" onmouseout="this.style.backgroundColor='#f3f4f6'">
                            ${_('sidebar.confirmations.clearAllHistory.cancel') || 'Cancel'}
                        </button>
                        <button id="confirm-clear-history" style="
                            padding: 8px 16px;
                            background: #dc2626;
                            color: white;
                            border: none;
                            border-radius: 6px;
                            font-size: 14px;
                            font-weight: 500;
                            cursor: pointer;
                            transition: all 0.2s;
                        " onmouseover="this.style.backgroundColor='#b91c1c'" onmouseout="this.style.backgroundColor='#dc2626'">
                            ${_('sidebar.confirmations.clearAllHistory.confirm') || 'Clear All'}
                        </button>
                    </div>
                </div>
            </div>
            <style>
                @keyframes modalSlideIn {
                    from {
                        opacity: 0;
                        transform: scale(0.95) translateY(-10px);
                    }
                    to {
                        opacity: 1;
                        transform: scale(1) translateY(0);
                    }
                }
            </style>
        `;
        
        // Ê∑ªÂä†Ê®°ÊÄÅÊ°ÜÂà∞È°µÈù¢
        $('body').append(modalHtml);
        
        // ÁªëÂÆöÂèñÊ∂àÊåâÈíÆ‰∫ã‰ª∂
        $('#cancel-clear-history').on('click', function() {
            $('#clear-history-modal').remove();
        });
        
        // ÁªëÂÆöÁ°ÆËÆ§ÊåâÈíÆ‰∫ã‰ª∂
        $('#confirm-clear-history').on('click', function() {
            // ÊòæÁ§∫Âä†ËΩΩÁä∂ÊÄÅ
            $(this).html('<i class="fa fa-spinner fa-spin"></i> ' + (_('sidebar.confirmations.clearAllHistory.clearing') || 'Clearing...'));
            $(this).prop('disabled', true);
            
            // ÂèëÈÄÅÂà†Èô§ËØ∑Ê±Ç
            $.ajax({
                url: '/ai-sidebar/sessions',
                method: 'DELETE',
                success: function(response) {
                    if (response.success) {
                        // Ê∏ÖÁ©∫ÂΩìÂâçËÅäÂ§©ÁïåÈù¢
                        $('#augment-chat-messages').empty();
                        
                        // ÈáçÁΩÆ‰ºöËØùID
                        currentSessionId = null;
                        localStorage.removeItem('node-red-ai-session-id');
                        
                        // ÂÖ≥Èó≠Ê®°ÊÄÅÊ°Ü
                        $('#clear-history-modal').remove();
                        
                        // ÂÖ≥Èó≠ÂéÜÂè≤ËÆ∞ÂΩï‰∏ãÊãâËèúÂçï
                        $('#chat-history-dropdown-menu').hide();
                        $('#chat-history-dropdown-btn .fa-chevron-up').removeClass('fa-chevron-up').addClass('fa-chevron-down');
                        
                        // ÊòæÁ§∫ÊàêÂäüÊ∂àÊÅØ
                        showNotification(_('sidebar.confirmations.clearAllHistory.success') || 'All chat history has been cleared successfully', 'success');
                    } else {
                        showNotification(_('sidebar.confirmations.clearAllHistory.error') || 'Failed to clear history. Please try again.', 'error');
                        $('#clear-history-modal').remove();
                    }
                },
                error: function(xhr, status, error) {
                    console.error('Failed to clear all sessions:', error);
                    showNotification(_('sidebar.confirmations.clearAllHistory.error') || 'Failed to clear history. Please try again.', 'error');
                    $('#clear-history-modal').remove();
                }
            });
        });
        
        // ÁÇπÂáªÊ®°ÊÄÅÊ°ÜËÉåÊôØÂÖ≥Èó≠
        $('#clear-history-modal').on('click', function(e) {
            if (e.target === this) {
                $(this).remove();
            }
        });
        
        // ESCÈîÆÂÖ≥Èó≠Ê®°ÊÄÅÊ°Ü
        $(document).on('keydown.clearHistoryModal', function(e) {
            if (e.keyCode === 27) { // ESC key
                $('#clear-history-modal').remove();
                $(document).off('keydown.clearHistoryModal');
            }
        });
    }
    
    // Create new session
    function createNewSession() {
        // Generate new session ID
        var newSessionId = 'session-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
        
        // Clear current chat area
        $('#augment-chat-messages').empty();
        
        // Update current session ID
        currentSessionId = newSessionId;
        localStorage.setItem('node-red-ai-session-id', newSessionId);
        
        // Close dropdown menu
        $('#chat-history-dropdown-menu').hide();
        $('#chat-history-dropdown-btn .fa-chevron-up').removeClass('fa-chevron-up').addClass('fa-chevron-down');
        
        // Add system prompt message
        addMessageToChat('system', `üÜï ${_('sidebar.labels.newSessionCreated') || 'New session created'}: ${newSessionId.substring(0, 8)}`);
        
        // Show success notification
        showNotification(_("sidebar.labels.newSessionCreatedSuccess"), 'success');
        
        // Focus on input
        $('#augment-input').focus();
    }
    
    // ÊòæÁ§∫ÈÄöÁü•Ê∂àÊÅØÁöÑËæÖÂä©ÂáΩÊï∞
    function showNotification(message, type = 'info') {
        const notificationHtml = `
            <div class="ai-notification" style="
                position: fixed;
                top: 20px;
                right: 20px;
                background: ${type === 'success' ? '#10b981' : type === 'error' ? '#ef4444' : '#3b82f6'};
                color: white;
                padding: 12px 16px;
                border-radius: 8px;
                box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
                z-index: 10001;
                animation: notificationSlideIn 0.3s ease-out;
                max-width: 300px;
                font-size: 14px;
            ">
                <div style="display: flex; align-items: center; gap: 8px;">
                    <i class="fa ${type === 'success' ? 'fa-check-circle' : type === 'error' ? 'fa-exclamation-circle' : 'fa-info-circle'}"></i>
                    <span>${message}</span>
                </div>
            </div>
            <style>
                @keyframes notificationSlideIn {
                    from {
                        opacity: 0;
                        transform: translateX(100%);
                    }
                    to {
                        opacity: 1;
                        transform: translateX(0);
                    }
                }
            </style>
        `;
        
        $('body').append(notificationHtml);
        
        // 3ÁßíÂêéËá™Âä®ÁßªÈô§ÈÄöÁü•
        setTimeout(function() {
            $('.ai-notification').fadeOut(300, function() {
                $(this).remove();
            });
        }, 3000);
    }

    function saveChatMessage(role, content) {
        // Save message to Node-RED global context (optional)
        try {
            var context = RED.settings.get('contextStorage') || {};
            if (context.default && context.default.module === 'localfilesystem') {
                // If file storage is configured, can save chat records
                // console.log("Save chat record:", role, content);
            }
        } catch (error) {
            // Failed to save chat record, ignore error
        }
    }

    // Get current selected model information
    function getCurrentModelInfo() {
        try {
            var nodeId = getSelectedConfigNodeId();
            if (!nodeId) {
                return { name: 'AI Assistant', firstLetter: 'A' };
            }
            
            var configNode = RED.nodes.node(nodeId);
            if (!configNode) {
                return { name: 'AI Assistant', firstLetter: 'A' };
            }
            
            var provider = configNode.provider || 'openai';
            
            // Generate display name and first letter based on provider
            var displayName = '';
            var firstLetter = '';
            
            switch (provider.toLowerCase()) {
                case 'openai':
                    displayName = 'OpenAI';
                    firstLetter = 'O';
                    break;
                case 'deepseek':
                    displayName = 'DeepSeek';
                    firstLetter = 'D';
                    break;
                case 'anthropic':
                    displayName = 'Claude';
                    firstLetter = 'C';
                    break;
                case 'google':
                    displayName = 'Gemini';
                    firstLetter = 'G';
                    break;
                default:
                    displayName = provider.charAt(0).toUpperCase() + provider.slice(1);
                    firstLetter = provider.charAt(0).toUpperCase();
            }
            
            return { name: displayName, firstLetter: firstLetter };
        } catch (error) {
            return { name: 'AI Assistant', firstLetter: 'A' };
        }
    }

    // Add message to chat UI with markdown rendering
    function addMessageToChat(role, content, messageId) {
        loadAISidebarConfig().then(function(config) {
            var isUser = role === "user";
            var userLabel = config.ui.userLabel;
            
            // Set label and icon based on role
            var label, avatarContent;
            if (isUser) {
                label = userLabel;
                avatarContent = userLabel.charAt(0).toUpperCase();
            } else {
                // AI message displays current provider name
                var modelInfo = getCurrentModelInfo();
                label = modelInfo.name;
                avatarContent = modelInfo.firstLetter;
            }
            
            var timestamp = new Date().toLocaleTimeString('en-US', { 
                hour: '2-digit', 
                minute: '2-digit',
                hour12: true 
            });
            
            var messageHtml = '<div class="augment-message-container ' + (isUser ? 'user-message' : 'assistant-message') + '" ' + 
                             (messageId ? 'id="' + messageId + '"' : '') + ' style="margin: 0 0 24px 0;">';
            
            // Message header
            messageHtml += '<div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">';
            messageHtml += '<div style="width: 24px; height: 24px; border-radius: 50%; background: ' + 
                          (isUser ? '#3b82f6' : '#10b981') + '; display: flex; align-items: center; justify-content: center;">';
            messageHtml += '<span style="color: white; font-size: 12px; font-weight: 600;">' + avatarContent + '</span>';
            messageHtml += '</div>';
            messageHtml += '<span style="font-weight: 600; color: #374151;">' + label + '</span>';
            
            // Add scenario information with smaller font
            if (!isUser && ScenarioManager.isLoaded) {
                var currentScenario = ScenarioManager.getCurrentScenario();
                // Get actual scenario data structure
                var scenarios = ScenarioManager.scenarios.scenarios || ScenarioManager.scenarios;
                if (scenarios[currentScenario]) {
                    var scenarioName = scenarios[currentScenario].name;
                    messageHtml += '<span style="color: #6b7280; font-size: 11px; font-weight: 400; margin-left: 4px;">- ' + scenarioName + '</span>';
                }
            }
            
            messageHtml += '<span style="color: #9ca3af; font-size: 12px; margin-left: auto;">' + timestamp + '</span>';
            messageHtml += '</div>';
            
            // Message content with markdown rendering
            var renderedContent;
            renderedContent = renderMarkdown(content);
            messageHtml += '<div class="message-content" style="background: ' + (isUser ? '#f3f4f6' : '#ffffff') + 
                          '; padding: 12px 16px; border-radius: 12px; border: 1px solid #e5e7eb; word-wrap: break-word; line-height: 1.5;">';
            messageHtml += renderedContent;
            messageHtml += '</div>';
            messageHtml += '</div>';
            
            $("#augment-chat-messages").append(messageHtml);
            
            // Get the newly added message element
            var messageElement = $("#augment-chat-messages .augment-message-container").last();
            
            // Apply syntax highlighting if highlight.js is available
            if (typeof hljs !== 'undefined') {
                messageElement.find('pre code').each(function(i, block) {
                    try {
                        hljs.highlightElement(block);
                    } catch (e) {
                        // Syntax highlighting failed, ignore error
                    }
                });
            }
            
            // Detect action markers
            if (messageId) {
                detectAndProcessActionMarkers(messageId);
            }
            
            // Add markdown styles
            addMarkdownStyles();
            
            forceScrollToBottom();
        });
    }

    // Add markdown styles to the page
    function addMarkdownStyles() {
        // Check if styles already added
        if (document.getElementById('markdown-styles')) {
            return;
        }
        
        var style = document.createElement('style');
        style.id = 'markdown-styles';
        style.textContent = `
            /* Use higher priority selectors to override Node-RED default styles */
            .augment-message-container .message-content h1, 
            .augment-message-container .message-content h2, 
            .augment-message-container .message-content h3, 
            .augment-message-container .message-content h4, 
            .augment-message-container .message-content h5, 
            .augment-message-container .message-content h6 {
                margin: 16px 0 8px 0 !important;
                font-weight: 600 !important;
                line-height: 1.25 !important;
                color: #1f2937 !important;
            }
            .augment-message-container .message-content h1 { 
                font-size: 1.5em !important; 
                border-bottom: 1px solid #e5e7eb !important; 
                padding-bottom: 8px !important; 
            }
            .augment-message-container .message-content h2 { font-size: 1.3em !important; }
            .augment-message-container .message-content h3 { font-size: 1.1em !important; }
            .augment-message-container .message-content h4, 
            .augment-message-container .message-content h5, 
            .augment-message-container .message-content h6 { font-size: 1em !important; }
            
            .augment-message-container .message-content p {
                margin: 8px 0 !important;
                line-height: 1.6 !important;
                color: #374151 !important;
            }
            
            .augment-message-container .message-content ul, 
            .augment-message-container .message-content ol {
                margin: 8px 0 !important;
                padding-left: 20px !important;
            }
            .augment-message-container .message-content li {
                margin: 4px 0 !important;
                line-height: 1.5 !important;
                color: #374151 !important;
            }
            
            .augment-message-container .message-content blockquote {
                margin: 12px 0 !important;
                padding: 8px 16px !important;
                border-left: 4px solid #e5e7eb !important;
                background: #f9fafb !important;
                font-style: italic !important;
                color: #6b7280 !important;
            }
            
            .augment-message-container .message-content pre {
                margin: 12px 0 !important;
                padding: 12px !important;
                background: #f8fafc !important;
                border: 1px solid #e2e8f0 !important;
                border-radius: 6px !important;
                overflow-x: auto !important;
                font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', 'Consolas', monospace !important;
                font-size: 13px !important;
                line-height: 1.4 !important;
                white-space: pre !important;
            }
            
            .augment-message-container .message-content code {
                background: #f1f5f9 !important;
                padding: 2px 4px !important;
                border-radius: 3px !important;
                font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', 'Consolas', monospace !important;
                font-size: 0.9em !important;
                color: #dc2626 !important;
            }
            
            .augment-message-container .message-content pre code {
                background: none !important;
                padding: 0 !important;
                border-radius: 0 !important;
                color: #334155 !important;
            }
            
            .augment-message-container .message-content table {
                margin: 12px 0 !important;
                border-collapse: collapse !important;
                width: 100% !important;
            }
            .augment-message-container .message-content th, 
            .augment-message-container .message-content td {
                border: 1px solid #e5e7eb !important;
                padding: 8px 12px !important;
                text-align: left !important;
            }
            .augment-message-container .message-content th {
                background: #f9fafb !important;
                font-weight: 600 !important;
            }
            
            .augment-message-container .message-content a {
                color: #3b82f6 !important;
                text-decoration: none !important;
            }
            .augment-message-container .message-content a:hover {
                text-decoration: underline !important;
            }
            
            .augment-message-container .message-content hr {
                margin: 16px 0 !important;
                border: none !important;
                border-top: 1px solid #e5e7eb !important;
            }
            
            .augment-message-container .message-content strong {
                font-weight: 600 !important;
                color: #1f2937 !important;
            }
            
            .augment-message-container .message-content em {
                font-style: italic !important;
                color: #6b7280 !important;
            }
            
            .augment-message-container .message-content del {
                text-decoration: line-through !important;
                color: #9ca3af !important;
            }
            
            /* Task list styles */
            .augment-message-container .message-content input[type="checkbox"] {
                margin-right: 8px !important;
            }
            
            /* Highlight.js theme override for better integration */
            .augment-message-container .message-content .hljs {
                background: #f8fafc !important;
                color: #334155 !important;
            }
        `;
        document.head.appendChild(style);
    }

    // Append content to existing message with markdown rendering
    function appendToMessage(messageId, content) {
        var messageElement = $("#" + messageId + " .message-content");
        if (messageElement.length > 0) {
            // Get current text content (not HTML to avoid double-rendering)
            var currentText = messageElement.attr('data-raw-text') || '';
            var newText = currentText + content;
            
            // Store raw text for future appends
            messageElement.attr('data-raw-text', newText);
            
            // Render combined content as markdown
            var renderedContent = renderMarkdown(newText);
            
            messageElement.html(renderedContent);
            
            // Apply syntax highlighting if highlight.js is available
            if (typeof hljs !== 'undefined') {
                messageElement.find('pre code').each(function(i, block) {
                    try {
                        hljs.highlightElement(block);
                    } catch (e) {
                        // Syntax highlighting failed, ignore error
                    }
                });
            }
            
            // Enhance code block display - ensure execution after syntax highlighting
            setTimeout(function() {
                enhanceCodeBlocks(messageElement);
            }, 100);
            
            // Scroll to bottom
            forceScrollToBottom();
        }
    }

    // Load external libraries for markdown rendering
    function loadMarkdownLibraries() {
        return new Promise((resolve) => {
            let loadedCount = 0;
            const totalLibraries = 2;
            
            function checkComplete() {
                loadedCount++;
                if (loadedCount === totalLibraries) {
                    resolve();
                }
            }
            
            // Load showdown.js for markdown rendering
            if (typeof showdown === 'undefined') {
                var showdownScript = document.createElement('script');
                showdownScript.src = 'https://cdn.jsdelivr.net/npm/showdown@2.1.0/dist/showdown.min.js';
                showdownScript.onload = function() {
                    checkComplete();
                };
                showdownScript.onerror = function() {
                    checkComplete();
                };
                document.head.appendChild(showdownScript);
            } else {
                checkComplete();
            }
            
            // Load highlight.js for syntax highlighting
            if (typeof hljs === 'undefined') {
                var hlScript = document.createElement('script');
                hlScript.src = 'https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/highlight.min.js';
                hlScript.onload = function() {
                    
                    // Load CSS for highlight.js
                    var hlCss = document.createElement('link');
                    hlCss.rel = 'stylesheet';
                    hlCss.href = 'https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/styles/github.min.css';
                    document.head.appendChild(hlCss);
                    
                    checkComplete();
                };
                hlScript.onerror = function() {
                    checkComplete();
                };
                document.head.appendChild(hlScript);
            } else {
                checkComplete();
            }
        });
    }
    
    function forceScrollToBottom() {
        // Method 1: Use jQuery's scrollTop
        var chatContainer = $("#augment-chat-messages");
        chatContainer.scrollTop(chatContainer[0].scrollHeight);
        
        // Method 2: Use native JavaScript's scrollTo
        var container = document.getElementById("augment-chat-messages");
        if (container) {
            container.scrollTo(0, container.scrollHeight);
        }
        
        // Method 3: Use setTimeout to ensure DOM is updated
        setTimeout(function() {
            chatContainer.scrollTop(chatContainer[0].scrollHeight);
        }, 50);
    }
    // Add configuration loading function
    function loadAISidebarConfig() {
        return Promise.resolve({
            ui: {
                placeholder: "Ask or instruct Augment",
                currentFlow: "Current Flow",
                currentNode: "Current Node",
                noFlowSelected: "No Flow Selected",
                noNodeSelected: "No Node Selected",
                multipleNodesSelected: "{count} Nodes Selected",
                nodeType: "Type",
                timestamp: "07:51 PM",
                userLabel: "You",
                assistantLabel: "Augment"
            },
            messages: {
                developmentInProgress: "This feature is under development",
                simulatedResponse: "This is a simulated AI response."
            }
        });
    }
    // Add action button to message
    function addActionButton(messageId, buttonData) {
        var messageElement = $("#" + messageId);
        if (messageElement.length > 0) {
            
            // Create button HTML, mimicking Augment UI style Apply button
            var buttonHtml = `
                <div class="action-button-container" style="
                    margin-top: 16px; 
                    padding: 0;
                    display: flex;
                    justify-content: flex-end;
                ">
                    <button class="execute-tool-btn" 
                            data-tool-name="${buttonData.toolName}" 
                            data-tool-args='${JSON.stringify(buttonData.toolArgs)}'
                            style="
                                background: #10b981;
                                border: 1px solid #10b981;
                                border-radius: 6px;
                                padding: 6px 12px;
                                font-size: 13px;
                                color: white;
                                cursor: pointer;
                                display: inline-flex;
                                align-items: center;
                                gap: 6px;
                                transition: all 0.2s;
                                font-weight: 500;
                                min-width: 60px;
                                justify-content: center;
                            "
                            onmouseover="this.style.background='#059669'"
                            onmouseout="this.style.background='#10b981'">
                        <i class="fa fa-check" style="font-size: 12px;"></i>
                        ${_("sidebar.buttons.apply")}
                    </button>
                </div>
            `;
            
            messageElement.find('.message-content').append(buttonHtml);
            forceScrollToBottom();
        } else {
            // Message element not found
        }
    }

    // Button click event handling
    $(document).on('click', '.execute-tool-btn', function() {
        var toolName = $(this).data('tool-name');
        var toolArgs = $(this).data('tool-args');
        var button = $(this);
        var originalText = button.html();
        
        // Get current selected flow information
        var selectedFlow = null;
        try {
            var activeWorkspace = RED.workspaces.active();
            if (activeWorkspace) {
                selectedFlow = {
                    id: activeWorkspace,
                    label: RED.nodes.workspace(activeWorkspace).label
                };
            }
        } catch (error) {
            // Failed to get current flow
        }
        
        // Disable button and show loading state
        button.prop('disabled', true)
              .html('<i class="fa fa-spinner fa-spin" style="font-size: 12px;"></i> ' + _("sidebar.labels.executing"))
              .css({
                  'background': '#f3f4f6',
                  'color': '#6b7280',
                  'cursor': 'not-allowed'
              });
        
        // Get configuration node ID
        var nodeId = getSelectedConfigNodeId();
        if (!nodeId) {
            addMessageToChat("error", "‚ùå Configuration node not found, please create and configure API key first");
            button.prop('disabled', false).html(originalText);
            return;
        }
        
        // Execute tool call
        
        // Send tool execution request
        $.ajax({
            url: '/ai-sidebar/execute-tool',
            method: 'POST',
            contentType: 'application/json',
            data: JSON.stringify({
                toolName: toolName,
                parameters: toolArgs,
                nodeId: nodeId,
                selectedFlow: selectedFlow
            }),
            success: function(response) {
                if (response.success) {
                    // Show execution success
                    button.html('<i class="fa fa-check" style="font-size: 12px;"></i> ' + _("sidebar.labels.completed"))
                          .css({
                              'background': '#dcfce7',
                              'color': '#166534',
                              'border-color': '#bbf7d0'
                          });
                    
                    // Add success message
                    addMessageToChat("assistant", `‚úÖ ${toolName} executed successfully!\n\n${response.result}`);
                    
                    // Refresh logic removed - using apply button refresh only
                } else {
                    // Show execution failed
                    button.prop('disabled', false)
                          .html('<i class="fa fa-exclamation-triangle" style="font-size: 12px;"></i> ' + _("sidebar.buttons.retry"))
                          .css({
                              'background': '#fef2f2',
                              'color': '#dc2626',
                              'border-color': '#fecaca'
                          });
                    
                    addMessageToChat("error", `‚ùå ${_("sidebar.messages.executionFailed")}: ${response.error}`);
                }
            },
            error: function(xhr) {
                var error = xhr.responseJSON ? xhr.responseJSON.error : 'Network error';
                
                // Restore button state
                button.prop('disabled', false)
                      .html('<i class="fa fa-exclamation-triangle" style="font-size: 12px;"></i> ' + _("sidebar.buttons.retry"))
                      .css({
                          'background': '#fef2f2',
                          'color': '#dc2626',
                          'border-color': '#fecaca'
                      });
                
                addMessageToChat("error", `‚ùå ${_("sidebar.messages.executionFailed")}: ${error}`);
            }
        });
    });
    // Add JSON editor to message
    function addJSONEditor(messageId, editorData) {
        var messageElement = $("#" + messageId);
        
        if (messageElement.length > 0) {
            var editorId = "json-editor-" + Date.now();
            
            // Create editor HTML
            var editorHtml = `
                <div class="json-editor-container" style="margin-top: 16px;">
                    <div style="margin-bottom: 8px;">
                        <strong>${editorData.editorTitle || _("sidebar.labels.flowConfiguration")}</strong>
                    </div>
                    <div style="margin-bottom: 12px; color: #6b7280; font-size: 14px;">
                        ${editorData.description || ''}
                    </div>
                    <div id="${editorId}" style="
                        height: 300px;
                        border: 1px solid #e5e7eb;
                        border-radius: 6px;
                        margin-bottom: 12px;
                    "></div>
                    <div style="display: flex; justify-content: flex-end; gap: 8px;">
                        <button class="json-editor-apply-btn" 
                                data-editor-id="${editorId}"
                                data-tool-name="${editorData.toolName}" 
                                data-tool-args='${JSON.stringify(editorData.toolArgs)}'
                                style="
                                    background: #10b981;
                                    border: 1px solid #10b981;
                                    border-radius: 6px;
                                    padding: 8px 16px;
                                    font-size: 14px;
                                    color: white;
                                    cursor: pointer;
                                    display: inline-flex;
                                    align-items: center;
                                    gap: 6px;
                                    transition: all 0.2s;
                                    font-weight: 500;
                                "
                                onmouseover="this.style.background='#059669'"
                                onmouseout="this.style.background='#10b981'">
                            <i class="fa fa-check" style="font-size: 12px;"></i>
                            ${_("sidebar.buttons.apply")}
                        </button>
                    </div>
                </div>
            `;
            
            // Add editor HTML
            messageElement.find('.message-content').append(editorHtml);
            
            // Initialize JSON editor
            ensureAceEditorLoaded(function() {
                initializeJSONEditor(editorId, editorData.jsonContent);
            });
            
            // Add Apply button click event
            messageElement.find('.json-editor-apply-btn').off('click').on('click', function() {
                var editorId = $(this).data('editor-id');
                var toolName = $(this).data('tool-name');
                var originalToolArgs = $(this).data('tool-args');
                
                // Get editor content
                var editor = window.jsonEditors && window.jsonEditors[editorId];
                if (!editor) {
                    RED.notify(_("sidebar.messages.editorNotFound"), "error");
                    return;
                }
                
                var editedContent = editor.getValue();
                
                // Validate JSON format
                try {
                    var parsedJson = JSON.parse(editedContent);
                    
                    // Update tool parameters
                    var updatedToolArgs = Object.assign({}, originalToolArgs);
                    if (toolName === 'create-flow') {
                        updatedToolArgs.flowJson = editedContent;
                    }
                    
                    // Execute tool
                    
                    // Disable button
                    $(this).prop('disabled', true)
                           .html('<i class="fa fa-spinner fa-spin" style="font-size: 12px;"></i> ' + _("sidebar.labels.executing"))
                           .css({
                               'background': '#f3f4f6',
                               'color': '#6b7280',
                               'cursor': 'not-allowed'
                           });
                    
                    // Call the tool execution API
                    executeJSONEditorTool(toolName, updatedToolArgs, $(this));
                    
                } catch (e) {
                    RED.notify(_("sidebar.messages.jsonFormatError") + ": " + e.message, "error");
                    // Highlight error line
                    document.getElementById(editorId).style.borderColor = '#dc3545';
                }
            });
            
            forceScrollToBottom();
            // JSON editor addition completed
        } else {
            // Message element not found
        }
    }
    
    // Execute JSON editor tool call
    function executeJSONEditorTool(toolName, toolArgs, buttonElement) {
        // Execute JSON editor tool call
        
        var nodeId = getSelectedConfigNodeId();
        if (!nodeId) {
            addMessageToChat("error", "‚ùå Êú™ÊâæÂà∞ÈÖçÁΩÆËäÇÁÇπÔºåËØ∑ÂÖàÂàõÂª∫Âπ∂ÈÖçÁΩÆAPIÂØÜÈí•");
            buttonElement.prop('disabled', false).html('<i class="fa fa-check"></i> Apply');
            return;
        }
        
        var selectedFlow = null;
        try {
            var activeWorkspace = RED.workspaces.active();
            if (activeWorkspace) {
                selectedFlow = {
                    id: activeWorkspace,
                    label: RED.nodes.workspace(activeWorkspace).label
                };
            }
        } catch (error) {
            // Failed to get current flow
        }
        
        fetch('/ai-sidebar/execute-tool', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                toolName: toolName,
                parameters: toolArgs,
                nodeId: nodeId,
                selectedFlow: selectedFlow
            })
        })
        .then(response => response.json())
        .then(data => {
            // Tool execution result
            
            if (data.success) {
                // Successfully executed
                buttonElement.removeClass('execute-tool-btn')
                    .css({
                        'background': '#059669',
                        'cursor': 'default'
                    })
                    .html('<i class="fa fa-check"></i> ' + _("sidebar.labels.applied"))
                    .prop('disabled', true);
                
                // Show success message
                addMessageToChat("system", "‚úÖ " + _("sidebar.messages.flowCreationSuccess"));
                
                // Enhanced refresh logic with detailed logging
                console.log('=== APPLY BUTTON REFRESH LOGIC START ===');
                console.log('Flow creation successful, refreshing workspace...');
                console.log('Response data:', data);
                
                // Check initial state
                checkRefreshStatus();
                
                // Force reload flows from server
                if (RED.nodes && RED.nodes.load) {
                    console.log('RED.nodes.load is available, starting reload...');
                    RED.nodes.load().then(function() {
                        console.log('RED.nodes.load completed successfully');
                        
                        // Check state after reload
                        console.log('Checking state after RED.nodes.load...');
                        checkRefreshStatus();
                        
                        // Refresh workspace list
                        if (RED.workspaces && RED.workspaces.refresh) {
                            console.log('Calling RED.workspaces.refresh()...');
                            RED.workspaces.refresh();
                            console.log('RED.workspaces.refresh() completed');
                        } else {
                            console.warn('RED.workspaces.refresh not available');
                        }
                        
                        // Trigger view redraw
                        if (RED.view && RED.view.redraw) {
                            console.log('Calling RED.view.redraw()...');
                            RED.view.redraw();
                            console.log('RED.view.redraw() completed');
                        } else {
                            console.warn('RED.view.redraw not available');
                        }
                        
                        // Check state after refresh
                        setTimeout(function() {
                            console.log('Checking state 1 second after refresh...');
                            checkRefreshStatus();
                        }, 1000);
                        
                        // Extract flow ID from response and switch to new flow
                        console.log('Searching for flow ID in response result:', data.result);
                        var flowIdMatch = data.result.match(/(?:ID|id):\s*([a-f0-9-]+)/i);
                        if (flowIdMatch && flowIdMatch[1]) {
                            var newFlowId = flowIdMatch[1];
                            console.log('Found new flow ID:', newFlowId);
                            
                            // Wait a bit more for UI to update, then switch
                            setTimeout(function() {
                                if (RED.workspaces && RED.workspaces.show) {
                                    console.log('Switching to new flow:', newFlowId);
                                    RED.workspaces.show(newFlowId);
                                    console.log('Flow switch completed');
                                } else {
                                    console.warn('RED.workspaces.show not available');
                                }
                                
                                // Force another redraw after switching
                                if (RED.view && RED.view.redraw) {
                                    console.log('Final redraw after flow switch...');
                                    RED.view.redraw();
                                    console.log('Final redraw completed');
                                }
                                
                                // Final state check
                                setTimeout(function() {
                                    console.log('Final state check after flow switch...');
                                    checkRefreshStatus();
                                    console.log('=== APPLY BUTTON REFRESH LOGIC END ===');
                                }, 500);
                            }, 500);
                        } else {
                            console.log('No flow ID found in response:', data.result);
                            console.log('FlowIdMatch result:', flowIdMatch);
                            console.log('=== APPLY BUTTON REFRESH LOGIC END ===');
                        }
                    }).catch(function(error) {
                        console.error('Failed to reload flows:', error);
                        // Fallback to basic refresh
                        console.log('Using fallback refresh methods...');
                        if (RED.workspaces && RED.workspaces.refresh) {
                            console.log('Fallback: calling RED.workspaces.refresh()...');
                            RED.workspaces.refresh();
                        }
                        if (RED.view && RED.view.redraw) {
                            console.log('Fallback: calling RED.view.redraw()...');
                            RED.view.redraw();
                        }
                        console.log('=== APPLY BUTTON REFRESH LOGIC END (with error) ===');
                    });
                } else {
                    console.log('RED.nodes.load not available, using fallback refresh...');
                    // Fallback refresh method
                    if (RED.workspaces && RED.workspaces.refresh) {
                        console.log('Fallback: calling RED.workspaces.refresh()...');
                        RED.workspaces.refresh();
                    } else {
                        console.warn('RED.workspaces.refresh not available in fallback');
                    }
                    
                    if (RED.view && RED.view.redraw) {
                        console.log('Fallback: calling RED.view.redraw()...');
                        RED.view.redraw();
                    } else {
                        console.warn('RED.view.redraw not available in fallback');
                    }
                    
                    // Try to extract and switch to new flow
                    console.log('Fallback: searching for flow ID in response result:', data.result);
                    var flowIdMatch = data.result.match(/(?:ID|id):\s*([a-f0-9-]+)/i);
                    if (flowIdMatch && flowIdMatch[1]) {
                        var newFlowId = flowIdMatch[1];
                        console.log('Fallback: found new flow ID:', newFlowId);
                        setTimeout(function() {
                            if (RED.workspaces && RED.workspaces.show) {
                                console.log('Fallback: switching to new flow:', newFlowId);
                                RED.workspaces.show(newFlowId);
                                console.log('Fallback: flow switch completed');
                            } else {
                                console.warn('Fallback: RED.workspaces.show not available');
                            }
                        }, 500);
                    }
                    console.log('=== APPLY BUTTON REFRESH LOGIC END (fallback) ===');
                }
            } else {
                // Execution failed
                buttonElement.prop('disabled', false)
                    .css('background', '#ef4444')
                    .text(_("sidebar.messages.executionFailed"));
                
                addMessageToChat("error", "‚ùå " + _("sidebar.messages.toolExecutionFailed") + ": " + data.error);
                
                // Restore button after 3 seconds
                setTimeout(() => {
                    buttonElement.css('background', '#10b981').text('Apply');
                }, 3000);
            }
        })
        .catch(error => {
            // Tool execution error
            buttonElement.prop('disabled', false)
                      .html('<i class="fa fa-exclamation-triangle" style="font-size: 12px;"></i> ' + _("sidebar.buttons.retry"))
                      .css({
                          'background': '#fef2f2',
                          'color': '#dc2626',
                          'border-color': '#fecaca'
                      });
            
            addMessageToChat("error", "‚ùå Network error: " + error.message);
        });
    }
    // Global function definitions - must be at the beginning
    function ensureAceEditorLoaded(callback) {
        if (typeof ace !== 'undefined') {
            callback();
            return;
        }
        
        // If ACE is not loaded, try to load from Node-RED
        if (RED && RED.editor && RED.editor.ace) {
            window.ace = RED.editor.ace;
            callback();
            return;
        }
        
        // Final fallback option
        // ACE editor not found, will use plain text display
        callback();
    }

    function initializeJSONEditor(editorId, jsonContent) {
        try {
            // Validate JSON format
            var parsedJSON;
            try {
                parsedJSON = JSON.parse(jsonContent);
            } catch (e) {
                // If not valid JSON, display as plain text
                document.getElementById(editorId).innerHTML = '<pre style="padding: 12px; margin: 0; background: #f8f9fa; color: #495057; white-space: pre-wrap; word-wrap: break-word;">' + jsonContent + '</pre>';
                return;
            }
            
            // Create ACE editor
            var editor = ace.edit(editorId);
            editor.setTheme("ace/theme/textmate");
            editor.session.setMode("ace/mode/json");
            editor.setValue(JSON.stringify(parsedJSON, null, 2), -1);
            
            // Set editor options
            editor.setOptions({
                fontSize: 13,
                showPrintMargin: false,
                highlightActiveLine: true,
                showGutter: true,
                readOnly: false,
                maxLines: 20,
                minLines: 10,
                wrap: true,
                autoScrollEditorIntoView: true
            });
            
            // Store editor instance for later operations
            window.jsonEditors = window.jsonEditors || {};
            window.jsonEditors[editorId] = editor;
            
            // Listen for content changes
            editor.session.on('change', function() {
                try {
                    var content = editor.getValue();
                    JSON.parse(content); // Validate JSON format
                    // If JSON is valid, remove error styling
                    document.getElementById(editorId).style.borderColor = '#e9ecef';
                } catch (e) {
                    // If JSON is invalid, add error styling
                    document.getElementById(editorId).style.borderColor = '#dc3545';
                }
            });
            
        } catch (error) {
            // Failed to initialize JSON editor
            // Fallback to display as plain code block
            document.getElementById(editorId).innerHTML = '<pre style="padding: 12px; margin: 0; background: #f8f9fa; color: #495057; white-space: pre-wrap; word-wrap: break-word;">' + jsonContent + '</pre>';
        }
    }

    // Show scenario selection menu
    function showScenarioMenu(e) {
        // Show scenario selection menu
        
        // Remove existing menu
        $('.scenario-menu').remove();
        // Existing menu removed
        
        // Add detailed debug information
        // Check ScenarioManager status
        
        // Check if scenario data is loaded
        if (!ScenarioManager.isLoaded || Object.keys(ScenarioManager.scenarios).length === 0) {
            // console.warn('Âú∫ÊôØÊï∞ÊçÆÊú™Âä†ËΩΩÔºåÊó†Ê≥ïÊòæÁ§∫ËèúÂçï');
            
            // Try to reload scenario data
            // Attempting to reload scenario data
            ScenarioManager.loadScenarios().then(() => {
                // Scenario data reloaded successfully
                showScenarioMenu(e);
            }).catch(error => {
                // Failed to reload scenario data
                // Show error message
                addMessageToChat('error', '‚ùå ' + _("sidebar.messages.failedToLoadScenarioData"));
            });
            return;
        }
        
        // Scenario icon mapping
        var scenarioIcons = {
            'learning': 'üéì',
            'solution': 'üí°', 
            'integration': 'üîå',
            'development': 'üíª',
            'configuration': '‚öôÔ∏è',
            'management': 'üñ•Ô∏è',
            'general': 'üí¨'
        };
        
        // Dynamically generate scenario options
        var scenarioOptions = '';
        // Get actual scenario data
        var scenarios = ScenarioManager.scenarios.scenarios || ScenarioManager.scenarios;
        
        Object.keys(scenarios).forEach(function(scenarioId) {
            var scenario = scenarios[scenarioId];
            var icon = scenarioIcons[scenarioId] || 'üìã';
            
            scenarioOptions += `
                <div class="scenario-option" data-scenario="${scenarioId}" style="
                    padding: 6px 12px;
                    cursor: pointer;
                    display: flex;
                    align-items: center;
                    gap: 8px;
                    color: #374151;
                    transition: background-color 0.1s;
                " onmouseover="this.style.backgroundColor='#f3f4f6'" onmouseout="this.style.backgroundColor='transparent'">
                    <span style="font-size: 14px;">${icon}</span>
                    <span>${scenario.name}</span>
                </div>
            `;
        });
        
        // Create scenario selection menu
        // Start creating menu HTML
        
        var menuHtml = `
            <div class="scenario-menu" style="
                position: absolute;
                bottom: 60px;
                right: 16px;
                background: white;
                border: 1px solid #d1d5db;
                border-radius: 4px;
                box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
                z-index: 1000;
                min-width: 160px;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                font-size: 13px;
                padding: 4px 0;
            ">
                ${scenarioOptions}
            </div>
        `;
        
        // Menu HTML created
        
        // Add menu to page
        // Add menu to page
        $('#augment-chat-container').append(menuHtml);
        
        // Bind scenario selection events
        // Bind scenario selection events
        
        $('.scenario-option').on('click', function() {
            var scenarioId = $(this).data('scenario');
            ScenarioManager.switchScenario(scenarioId);
            $('.scenario-menu').remove();
        });
        
        // Close menu when clicking elsewhere
        // Bind document click event
        $(document).on('click.scenario-menu', function(e) {
            if (!$(e.target).closest('.scenario-menu, #augment-at-mention').length) {
                $('.scenario-menu').remove();
                $(document).off('click.scenario-menu');
            }
        });
        
        // showScenarioMenu function execution completed
    }

    // Enhance code block display - add toolbar for JSON code blocks
    function enhanceCodeBlocks(messageElement) {
        // Start enhancing code block display
        
        messageElement.find('pre code').each(function(index) {
            var $code = $(this);
            var $pre = $code.parent();
            var codeText = $code.text().trim();
            
            // Check if already processed
            if ($pre.hasClass('enhanced-code-block')) {
                return;
            }
            
            // Check if it's a JSON code block - supports object and array formats
            var isJsonFormat = (codeText.startsWith('{') && codeText.endsWith('}')) || 
                              (codeText.startsWith('[') && codeText.endsWith(']'));
            
            if (isJsonFormat) {
                try {
                    var parsedJson = JSON.parse(codeText);
                    // Check if it's flow configuration JSON
                    var isFlowConfig = false;
                    
                    if (Array.isArray(parsedJson)) {
                        // Array format: check if contains Node-RED nodes
                        isFlowConfig = parsedJson.some(item => 
                            item && typeof item === 'object' && 
                            (item.type === 'tab' || item.type || item.id || item.nodes)
                        );
                    } else if (typeof parsedJson === 'object' && parsedJson !== null) {
                        // Object format: check if it's flow configuration
                        isFlowConfig = parsedJson.nodes || parsedJson.label || parsedJson.id || 
                                      parsedJson.type || parsedJson.flows;
                    }
                    
                    // Check if it's flow configuration
                    
                    if (isFlowConfig) {
                        
                        // Mark as processed
                        $pre.addClass('enhanced-code-block');
                        
                        // Generate unique ID
                        var blockId = 'code-block-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
                        $pre.attr('id', blockId);
                        
                        // Get file name
                        var fileName = 'flow-config';
                        if (Array.isArray(parsedJson)) {
                            var tabNode = parsedJson.find(item => item.type === 'tab');
                            if (tabNode && tabNode.label) {
                                fileName = tabNode.label;
                            }
                        } else if (parsedJson.label || parsedJson.name) {
                            fileName = parsedJson.label || parsedJson.name;
                        }
                        
                        // Create toolbar HTML
                        var toolbarHtml = `
                            <div id="code-toolbar-${blockId}" class="code-toolbar" style="
                                height: 32px;
                                background: #f8f9fa;
                                border-bottom: 1px solid #e9ecef;
                                display: flex;
                                align-items: center;
                                justify-content: space-between;
                                padding: 0 12px;
                                font-size: 12px;
                                border-radius: 6px 6px 0 0;
                                box-sizing: border-box;
                                width: 100%;
                                flex-shrink: 0;
                                position: absolute;
                                top: 0;
                                left: 0;
                                right: 0;
                            ">
                                <!-- Left: Collapse button + File title -->
                                <div style="display: flex; align-items: center; gap: 8px; min-width: 0; flex: 1;">
                                    <button class="code-collapse-btn" data-block-id="${blockId}" style="
                                        background: none;
                                        border: none;
                                        color: #6c757d;
                                        cursor: pointer;
                                        padding: 2px 4px;
                                        border-radius: 3px;
                                        display: flex;
                                        align-items: center;
                                        font-size: 10px;
                                        line-height: 1;
                                        flex-shrink: 0;
                                    " title="Collapse/Expand">
                                        <i class="fa fa-chevron-down"></i>
                                    </button>
                                    <span style="
                                        color: #495057; 
                                        font-weight: 500; 
                                        font-size: 11px;
                                        white-space: nowrap;
                                        overflow: hidden;
                                        text-overflow: ellipsis;
                                        min-width: 0;
                                    ">
                                        <i class="fa fa-file-code-o" style="margin-right: 4px; color: #28a745; font-size: 10px;"></i>
                                        ${fileName}.json
                                    </span>
                                </div>
                                
                                <!-- Right: Action button group -->
                                <div style="display: flex; align-items: center; gap: 6px; position: relative; flex-shrink: 0;">
                                    <button class="code-more-btn" 
                                            data-block-id="${blockId}"
                                            data-json-content='${JSON.stringify(parsedJson).replace(/'/g, "&#39;")}'
                                            style="
                                                background: #28a745;
                                                border: none;
                                                border-radius: 4px;
                                                color: white;
                                                padding: 4px 8px;
                                                font-size: 11px;
                                                cursor: pointer;
                                                display: flex;
                                                align-items: center;
                                                gap: 4px;
                                                transition: all 0.2s;
                                                font-weight: 500;
                                                line-height: 1;
                                                white-space: nowrap;
                                                position: relative;
                                            "
                                            onmouseover="this.style.background='#218838'"
                                            onmouseout="this.style.background='#28a745'"
                                            title="Create Flow">
                                        <i class="fa fa-check" style="font-size: 9px;"></i>
                                        ${_("sidebar.buttons.apply")}
                                    </button>
                                </div>
                            </div>
                        `;
                        // Modify pre style to accommodate toolbar
                        $pre.css({
                            'position': 'relative',
                            'margin': '16px 0',
                            'border': '1px solid #e9ecef',
                            'border-radius': '6px',
                            'background': '#ffffff',
                            'padding-top': '32px',
                            'overflow': 'hidden',
                            'width': '100%',
                            'box-sizing': 'border-box'
                        });
                        
                        // Modify code style
                        $code.css({
                            'display': 'block',
                            'padding': '16px',
                            'background': 'transparent',
                            'border': 'none',
                            'border-radius': '0 0 6px 6px',
                            'max-height': '400px',
                            'overflow-x': 'hidden',
                            'overflow-y': 'auto',
                            'margin': '0',
                            'width': '100%',
                            'box-sizing': 'border-box',
                            'white-space': 'pre',
                            'word-wrap': 'normal'
                        });
                        
                        // Add toolbar to pre element
                        $pre.prepend(toolbarHtml);
                        
                        // JSON code block toolbar addition completed
                    }
                } catch (e) {
                    // JSON parsing failed, skip processing
                }
            }
        });
    }
    
    function copyEditorContent(editorId) {
        try {
            var editor = window.jsonEditors && window.jsonEditors[editorId];
            var content;
            
          
            if (editor) {
                content = editor.getValue();
            } else {
                // Fallback: get content from DOM
                var element = document.getElementById(editorId);
                content = element.textContent || element.innerText;
            }
            
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(content).then(function() {
                    RED.notify(_("sidebar.messages.contentCopied"), "success");
                }).catch(function(err) {
                    fallbackCopyTextToClipboard(content);
                });
            } else {
                fallbackCopyTextToClipboard(content);
            }
        } catch (error) {
            console.error("Error copying editor content:", error);
            RED.notify(_("sidebar.messages.copyFailed") + ": " + error.message, "error");
        }
    }

    function applyEditorContent(editorId) {
        try {
            var editor = window.jsonEditors && window.jsonEditors[editorId];
            if (!editor) {
                RED.notify("Editor not found", "error");
                return;
            }
            
            var content = editor.getValue();
            
            // Validate JSON format
            try {
                JSON.parse(content);
                RED.notify(_("sidebar.messages.jsonValidApplied"), "success");
                
                // Here you can add actual application logic, such as:
                // - Save to configuration file
                // - Update Node-RED configuration
                // - Send to backend API, etc.
                
            } catch (e) {
                RED.notify("JSON format error: " + e.message, "error");
            }
            
        } catch (error) {
            RED.notify(_("sidebar.messages.applicationFailed") + ": " + error.message, "error");
        }
    }

    function fallbackCopyTextToClipboard(text) {
        var textArea = document.createElement("textarea");
        textArea.value = text;
        
        // Avoid scrolling to bottom
        textArea.style.top = "0";
        textArea.style.left = "0";
        textArea.style.position = "fixed";
        
        document.body.appendChild(textArea);
        textArea.focus();
        textArea.select();
        
        try {
            var successful = document.execCommand('copy');
            if (successful) {
                RED.notify(_("sidebar.messages.contentCopied"), "success");
            } else {
                RED.notify(_("sidebar.messages.copyFailed"), "error");
            }
        } catch (err) {
            RED.notify(_("sidebar.messages.copyFailed"), "error");
        }
        
        document.body.removeChild(textArea);
    }
    // Render markdown content
    function renderMarkdown(content) {
        if (!content || typeof content !== 'string') {
            return content || '';
        }
        
        // Start rendering Markdown
        
        // Preprocessing: handle function node code in Node-RED flow JSON
        content = preprocessNodeRedFunctionCode(content);
        
        // Preprocessing: handle ACTION_TYPE markers
        content = preprocessActionType(content);
        
        // Check if showdown is available
        if (typeof showdown !== 'undefined') {
            try {
                var converter = new showdown.Converter({
                    tables: true,
                    strikethrough: true,
                    tasklists: true,
                    ghCodeBlocks: true,
                    smoothLivePreview: true,
                    simplifiedAutoLink: true,
                    excludeTrailingPunctuationFromURLs: true,
                    literalMidWordUnderscores: true,
                    simpleLineBreaks: true,
                    parseImgDimensions: true,
                    headerLevelStart: 1,
                    backslashEscapesHTMLTags: true
                });
                var result = converter.makeHtml(content);
                
                // Post-processing: restore button HTML in code blocks
                result = result.replace(/<code([^>]*)>([\s\S]*?)<\/code>/g, function(match, attrs, codeContent) {
                    // Find escaped button HTML in code blocks and restore
                    var processedContent = codeContent
                        .replace(new RegExp('&lt;button class=&quot;code-view-btn&quot;[\\s\\S]*?&gt;' + _('sidebar.messages.viewCode') + '&lt;\\/button&gt;', 'g'), 
                            function(buttonMatch) {
                                // Fully decode button HTML
                                var decodedButton = buttonMatch
                                    .replace(/&lt;/g, '<')
                                    .replace(/&gt;/g, '>')
                                    .replace(/&quot;/g, '"')
                                    .replace(/&amp;/g, '&')
                                    .replace(/&#39;/g, "'");
                                
                                // Restore button HTML
                                return decodedButton;
                            });
                    
                    return '<code' + attrs + '>' + processedContent + '</code>';
                });
                
                // Showdown rendering successful
                return result;
            } catch (error) {
                // Showdown rendering failed
            }
        }
        
        // Enhanced fallback with better regex patterns
        // Use fallback Markdown rendering
        
        // First handle line breaks, ensure correct paragraph separation
        var lines = content.split('\n');
        var processedLines = [];
        var inCodeBlock = false;
        var codeBlockContent = [];
        var codeBlockLang = '';
        
        for (var i = 0; i < lines.length; i++) {
            var line = lines[i];
            
            // Check code block start/end
            if (line.match(/^```(\w+)?/)) {
                if (!inCodeBlock) {
                    // Start code block
                    inCodeBlock = true;
                    codeBlockLang = line.match(/^```(\w+)?/)[1] || '';
                    codeBlockContent = [];
                } else {
                    // End code block
                    inCodeBlock = false;
                    var escapedCode = codeBlockContent.join('\n')
                        .replace(/&/g, '&amp;')
                        .replace(/</g, '&lt;')
                        .replace(/>/g, '&gt;')
                        .replace(/"/g, '&quot;')
                        .replace(/'/g, '&#39;');
                    processedLines.push('<pre><code class="' + codeBlockLang + '">' + escapedCode + '</code></pre>');
                    codeBlockContent = [];
                    codeBlockLang = '';
                }
                continue;
            }
            
            if (inCodeBlock) {
                codeBlockContent.push(line);
                continue;
            }
            
            // Handle headers
            if (line.match(/^#{1,6}\s/)) {
                var headerLevel = line.match(/^(#{1,6})/)[1].length;
                var headerText = line.replace(/^#{1,6}\s/, '');
                processedLines.push('<h' + headerLevel + '>' + headerText + '</h' + headerLevel + '>');
                continue;
            }
            
            // Handle list items
            if (line.match(/^\s*[\*\-\+]\s/)) {
                var listItem = line.replace(/^\s*[\*\-\+]\s/, '');
                processedLines.push('<li>' + listItem + '</li>');
                continue;
            }
            
            // Handle empty lines
            if (line.trim() === '') {
                processedLines.push('</p><p>');
                continue;
            }
            
            // Regular text line
            processedLines.push(line);
        }
        
        // Merge processed lines
        var result = processedLines.join('\n');
        
        // Handle inline formatting
        result = result
            // Inline code
            .replace(/`([^`\n]+)`/g, '<code style="background: #f1f5f9; padding: 2px 4px; border-radius: 3px; font-family: monospace; font-size: 0.9em;">$1</code>')
            // Bold
            .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
            // Italic
            .replace(/\*(.*?)\*/g, '<em>$1</em>')
            // Handle line breaks
            .replace(/\n/g, '<br>');
        
        // Wrap list items
        result = result.replace(/(<li>.*?<\/li>(?:<br><li>.*?<\/li>)*)/g, '<ul>$1</ul>');
        result = result.replace(/<br>(<li>)/g, '$1');
        result = result.replace(/(<\/li>)<br>/g, '$1');
        
        // Wrap paragraphs
        if (result && !result.startsWith('<')) {
            result = '<p>' + result + '</p>';
        }
        
        // Clean up redundant paragraph tags
        result = result.replace(/<\/p><p><\/p><p>/g, '</p><p>');
        result = result.replace(/<p><\/p>/g, '');
        
        // Fallback rendering completed
        return result;
    }
// Main code logic
(function() {
    var globalAutoLayoutConfigNode = null;
  
    var dothisOneTimePlease = () => {
        RED.events.off('runtime-state', dothisOneTimePlease);

        // Load markdown libraries for rendering and wait for completion
        loadMarkdownLibraries().then(() => {
            // Markdown libraries loaded, ready to render
            addMarkdownStyles();
        });

        // Load sidebar content template
        var content = $($('script[type="text/x-red"][data-template-name="make_iot_smart_sidebar"]').i18n().html());
       
        // Add AI assistant tab to right sidebar panel
        RED.sidebar.addTab({
            id: "ai-sidebar",
            label: _("sidebar.title"),
            name: _("sidebar.title"),
            content: content,
            closeable: true,
            disableOnEdit: false,
            iconClass: "fa fa-comment",
            onshow: function() {
                // Sidebar shown
            }
        });
        
        // Initialize scenario manager immediately, not dependent on sidebar display
        
        // Delayed initialization to ensure DOM elements are loaded
        setTimeout(async () => {
                    // Ensure i18n messages are loaded before initializing scenario manager
                    await loadI18nMessages();
                    
                    // Update context information
                    updateCurrentFlowName();
                    updateSelectedNodeInfo();
                    
                    // Initialize scenario manager and show welcome message after loading
                    ScenarioManager.loadScenarios().then(() => {
                        // Bind scenario selection events
                        $("#scenario-selector").on("change", function() {
                            var selectedScenario = $(this).val();
                            ScenarioManager.switchScenario(selectedScenario);
                        });
                        
                        // Bind scenario menu button events - after scenario data is loaded
                        // Starting to bind scenario menu button events
                        
                        $("#augment-at-mention").off('click').on("click", function(e) {
                            e.preventDefault();
                            // Scenario menu button clicked
                            showScenarioMenu(e);
                        });
                        
                        // Scenario menu button event binding completed
                        
                        // Removed auto-trigger click test code to avoid automatic scenario menu popup on page load
                        
                        // Initialize default scenario
                        ScenarioManager.updateUI();
                        
                        // Remove welcome dialog display
                        
                        // Add welcome message
                        var currentScenario = ScenarioManager.scenarios[ScenarioManager.currentScenario];
                        var welcomeMsg = _("sidebar.messages.welcome").replace("{scenarioName}", currentScenario ? currentScenario.name : _("sidebar.scenarios.learning.name"));
                        
                        addMessageToChat('assistant', welcomeMsg);
                    }).catch(error => {
                        // Scenario loading failed
                        // Use default scenario data as fallback
                        ScenarioManager.scenarios = {
                            learning: {
                                name: _("sidebar.scenarios.learning.name"),
                                description: _("sidebar.scenarios.learning.description"),
                                prompt: []
                            }
                        };
                        ScenarioManager.isLoaded = true;
                        ScenarioManager.updateUI();
                        
                        // Show fallback welcome message
                        var welcomeMsg = _("sidebar.messages.fallbackWelcome");
                        addMessageToChat('assistant', welcomeMsg);
                    });
                }, 100);

        // Configuration button event handling
        $("#show-config-node-button").on("click", function() {
            // Click configuration button
            
            try {
                var apiConfigNodes = [];
                RED.nodes.eachConfig(function(configNode) {
                    if (configNode.type === 'api-config') {
                        apiConfigNodes.push(configNode);
                    }
                });
                
                if (apiConfigNodes.length > 0) {
                    // Found api-config node, open edit interface
                    RED.editor.editConfig("", "api-config", apiConfigNodes[0].id);
                } else {
                    // No api-config node found, open edit dialog directly
                    RED.editor.editConfig("", "api-config");
                }
            } catch (error) {
                RED.notify(_("sidebar.messages.errorDisplayingConfigNode") + ": " + error.message, "error");
            }
        });
        
        // Initialize AI assistant UI
        setupAIAssistant();
        
        // Initialize current flow name display
        updateCurrentFlowName();
        
        // Initialize current selected node info
        updateSelectedNodeInfo();
        
        // Initialize chat history dropdown menu
        initChatHistoryDropdown();
        
        // Listen for workspace selection changes
        RED.events.on('workspace:change', updateCurrentFlowName);
        
        // Listen for node selection changes
        RED.events.on('view:selection-changed', updateSelectedNodeInfo);
    };
    RED.events.on('runtime-state', dothisOneTimePlease );
})();


</script>

<script type="text/x-red" data-template-name="make_iot_smart_sidebar">
    <div class="red-ui-sidebar-info">
        <div class="red-ui-sidebar-header red-ui-info-toolbar" style="display: flex; align-items: center; gap: 8px;">
            <span class="button-group"><a id="show-config-node-button" class="red-ui-button red-ui-button-small selected" href="#">
                <i class="fa fa-cog"></i></a></span>
            <div class="chat-history-dropdown-container" style="position: relative; flex: 1;">
                <button id="chat-history-dropdown-btn" class="red-ui-button red-ui-button-small" style="
                    width: 100%;
                    display: flex;
                    align-items: center;
                    justify-content: space-between;
                    padding: 4px 8px;
                    background: #f8f9fa;
                    border: 1px solid #d1d5db;
                    border-radius: 4px;
                    font-size: 12px;
                    color: #6b7280;
                    cursor: pointer;
                ">
                    <span style="display: flex; align-items: center; gap: 6px;">
                        <i class="fa fa-history" style="font-size: 11px;"></i>
                        <span id="chat-history-label" >Chat History</span>
                    </span>
                    <i class="fa fa-chevron-down" style="font-size: 10px;"></i>
                </button>
                <div id="chat-history-dropdown-menu" class="chat-history-menu" style="
                    display: none;
                    position: absolute;
                    top: 100%;
                    left: 0;
                    right: 0;
                    background: white;
                    border: 1px solid #d1d5db;
                    border-radius: 6px;
                    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
                    z-index: 1000;
                    max-height: 300px;
                    overflow-y: auto;
                    margin-top: 2px;
                    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                    min-width: 200px;
                    max-width: 350px;
                    width: auto;
                    box-sizing: border-box;
                ">
                    <div class="chat-history-empty" style="
                        padding: 16px;
                        text-align: center;
                        color: #9ca3af;
                        font-size: 12px;
                    " >No chat history available</div>
                </div>
            </div>
        </div>

        <div class="red-ui-debug-content red-ui-debug-content-list" id="augment-chat-messages" style="
            position: absolute; 
            top: 40px; 
            bottom: 130px; 
            left: 0; 
            right: 0; 
            overflow-y: auto; 
            padding: 20px 16px;
            background: #fafafa;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        ">
            <!-- Chat messages will be displayed here -->
        </div>

        <!-- Augment tool UI -->
        <div id="augment-chat-container" class="augment-chat-container" style="
            position: absolute; 
            bottom: 0; 
            left: 0; 
            right: 0; 
            background: #ffffff; 
            border-top: 1px solid #e5e7eb;
            padding: 5px; 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        ">
            <!-- Context information bar -->
            <div class="augment-chat-context" style="
                font-size: 12px; 
                color: #6b7280; 
                padding: 12px 16px;
                background: #f9fafb;
                border-radius: 8px;
                border: 1px solid #f3f4f6;
            ">
                <div style="display: flex; align-items: center; flex-wrap: wrap; gap: 12px;">
                    <span style="display: flex; align-items: center;">
                        <i class="fa fa-sitemap" style="margin-right: 6px; color: #374151;"></i> 
                        <span id="current-flow-name" style="font-weight: 500; color: #1f2937;" >No flow selected</span>
                    </span>
                    <span style="color: #d1d5db;">></span>
                    <span style="display: flex; align-items: center;">
                        <i class="fa fa-cube" style="margin-right: 6px; color: #374151;"></i>
                        <span id="current-selected-node" style="font-weight: 500; color: #1f2937;" >No node selected</span>
                    </span>
                    <span id="selected-node-type-container" style="display: none;">
                        <span style="color: #d1d5db;">|</span>
                        <span style="color: #6b7280;" >Type: <span id="current-selected-node-type" style="font-weight: 500; color: #1f2937;"></span></span>
                    </span>
                </div>
            </div>
            
            <!-- Input area -->
            <div class="augment-chat-input-container" style="
                border: 1px solid #d1d5db;
                border-radius: 12px;
                background: #ffffff;
                position: relative;
                transition: border-color 0.2s, box-shadow 0.2s;
            " onfocus="this.style.borderColor='#3b82f6'; this.style.boxShadow='0 0 0 3px rgba(59, 130, 246, 0.1)'" onblur="this.style.borderColor='#d1d5db'; this.style.boxShadow='none'">
                <textarea id="augment-chat-input" placeholder="Ask "  
                          style="
                              width: 100%; 
                              min-height: 80px; 
                              padding: 16px 60px 16px 16px; 
                              border: none;
                              border-radius: 12px; 
                              resize: none; 
                              outline: none; 
                              font-family: inherit; 
                              font-size: 14px; 
                              background: transparent; 
                              color: #374151; 
                              overflow: hidden;
                              line-height: 1.5;
                          "
                          rows="3"
                          onfocus="this.parentElement.style.borderColor='#3b82f6'; this.parentElement.style.boxShadow='0 0 0 3px rgba(59, 130, 246, 0.1)'"
                          onblur="this.parentElement.style.borderColor='#d1d5db'; this.parentElement.style.boxShadow='none'"></textarea>
                
                <!-- Toolbar -->
                <div style="
                    position: absolute;
                    bottom: 12px;
                    right: 12px;
                    display: flex;
                    align-items: center;
                    gap: 8px;
                ">
                    <!-- Tool buttons -->
                    <div style="display: flex; gap: 4px;">
                        <button id="augment-attach-file" style="
                            background: none;
                            border: none;
                            color: #6b7280;
                            cursor: pointer;
                            padding: 6px;
                            border-radius: 6px;
                            font-size: 14px;
                            transition: all 0.2s;
                            display: flex;
                            align-items: center;
                            justify-content: center;
                        " onmouseover="this.style.background='#f3f4f6'" onmouseout="this.style.background='none'">
                            <i class="fa fa-paperclip"></i>
                        </button>
                        <button id="augment-at-mention" style="
                            background: none;
                            border: none;
                            color: #6b7280;
                            cursor: pointer;
                            padding: 6px;
                            border-radius: 6px;
                            font-size: 14px;
                            transition: all 0.2s;
                            display: flex;
                            align-items: center;
                            justify-content: center;
                        " onmouseover="this.style.background='#f3f4f6'" onmouseout="this.style.background='none'">
                            <i class="fa fa-at"></i>
                            <span style="
                                font-size: 11px;
                                color: #6b7280;
                                display: flex;
                                align-items: center;
                                padding: 0 4px;
                                line-height: 1;
                            ">
                                <span id="current-scenario-name" style="font-weight: 500;" >General</span>
                            </span>
                        </button>
                    
                    </div>
                    
                    <!-- Send button -->
                    <button id="augment-send" style="
                        background: #3b82f6;
                        border: none;
                        border-radius: 8px;
                        color: white;
                        padding: 8px 16px;
                        font-size: 13px;
                        font-weight: 500;
                        cursor: pointer;
                        transition: background-color 0.2s;
                        display: flex;
                        align-items: center;
                        gap: 6px;
                    " onmouseover="this.style.background='#2563eb'" onmouseout="this.style.background='#3b82f6'">
                        <i class="fa fa-paper-plane"></i>
                        <span id="send-button-text"  >Send</span>
                    </button>
                </div>
            </div>
        </div>
    </div>
</script>

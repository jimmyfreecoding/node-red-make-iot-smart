<!--
  Copyright 2024 Zheng He
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
-->


<script type="text/javascript">
    var currentStreamMessageId = null;
    // æ›´æ–°å½“å‰flowåç§°çš„å‡½æ•°
    function updateCurrentFlowName() {
        try {
            // è·å–å½“å‰æ´»åŠ¨çš„workspace
            var activeWorkspace = RED.workspaces.active();
            
            if (activeWorkspace) {
                // è·å–workspaceèŠ‚ç‚¹
                var workspaceNode = RED.nodes.workspace(activeWorkspace);
                
                if (workspaceNode && workspaceNode.label) {
                    // æ›´æ–°æ˜¾ç¤ºçš„flowåç§°
                    $("#current-flow-name").text(workspaceNode.label);
                } else {
                    $("#current-flow-name").text("Flow " + activeWorkspace);
                }
            } else {
                $("#current-flow-name").text("æœªé€‰æ‹©æµç¨‹");
            }
        } catch (error) {
            console.warn("æ›´æ–°æµç¨‹åç§°å¤±è´¥:", error);
            $("#current-flow-name").text("æœªçŸ¥æµç¨‹");
        }
    }

    // æ›´æ–°å½“å‰é€‰ä¸­èŠ‚ç‚¹ä¿¡æ¯çš„å‡½æ•°
    function updateSelectedNodeInfo() {
        try {
            var selection = RED.view.selection();
            
            if (!selection || !selection.nodes || selection.nodes.length === 0) {
                $("#current-selected-node").text("æœªé€‰æ‹©èŠ‚ç‚¹");
                $("#selected-node-type-container").hide();
            } else if (selection.nodes.length === 1) {
                var node = selection.nodes[0];
                var nodeInfo = node.name || node.type || "æœªçŸ¥èŠ‚ç‚¹";
                $("#current-selected-node").text(nodeInfo);
                
                // æ˜¾ç¤ºèŠ‚ç‚¹ç±»å‹
                if (node.type) {
                    $("#current-selected-node-type").text(node.type);
                    $("#selected-node-type-container").show();
                } else {
                    $("#selected-node-type-container").hide();
                }
            } else {
                $("#current-selected-node").text("å·²é€‰æ‹© " + selection.nodes.length + " ä¸ªèŠ‚ç‚¹");
                $("#selected-node-type-container").hide();
            }
        } catch (error) {
            console.warn("æ›´æ–°èŠ‚ç‚¹ä¿¡æ¯å¤±è´¥:", error);
            $("#current-selected-node").text("æœªçŸ¥èŠ‚ç‚¹");
            $("#selected-node-type-container").hide();
        }
    }
    
    function setupAIAssistant() {
        // è‡ªåŠ¨è°ƒæ•´æ–‡æœ¬åŒºåŸŸé«˜åº¦
        $("#augment-chat-input").on("input", function() {
            this.style.height = "auto";
            this.style.height = Math.min(this.scrollHeight, 120) + "px";
        });
        
        // å‘é€æŒ‰é’®ç‚¹å‡»äº‹ä»¶
        $("#augment-send").on("click", function() {
            sendMessage();
        });
        
        // æŒ‰Enteré”®å‘é€æ¶ˆæ¯ï¼ˆShift+Enteræ¢è¡Œï¼‰
        $("#augment-chat-input").on("keydown", function(e) {
            if (e.key === "Enter" && !e.shiftKey) {
                e.preventDefault();
                sendMessage();
            }
        });
        
        // å·¥å…·æŒ‰é’®ç‚¹å‡»äº‹ä»¶
        $("#augment-attach-file, #augment-at-mention").on("click", function() {
            RED.notify("æ­¤åŠŸèƒ½æ­£åœ¨å¼€å‘ä¸­", "info");
        });
    }
    
    function sendMessage() {
        var message = $("#augment-chat-input").val().trim();
        if (message) {
            console.log("å‘é€æ¶ˆæ¯:", message);
            addMessageToChat("user", message);
            
            $("#augment-chat-input").val("");
            $("#augment-chat-input").css("height", "72px");
            
            // å‘é€åˆ°AIåå°
            sendToAI(message);
        }
    }

    function sendToAI(message) {
        var nodeId = getSelectedConfigNodeId();
        if (!nodeId) {
            addMessageToChat("error", "âŒ æœªæ‰¾åˆ°é…ç½®èŠ‚ç‚¹ï¼Œè¯·å…ˆåˆ›å»ºå¹¶é…ç½®APIå¯†é’¥");
            return;
        }

        // æ£€æŸ¥èŠ‚ç‚¹æ˜¯å¦å·²éƒ¨ç½²
        var configNode = RED.nodes.node(nodeId);
        if (!configNode) {
            addMessageToChat("error", "âŒ é…ç½®èŠ‚ç‚¹æœªéƒ¨ç½²ï¼Œè¯·ç‚¹å‡»éƒ¨ç½²æŒ‰é’®åé‡è¯•");
            return;
        }

        // æ£€æŸ¥æ˜¯å¦æœ‰æœªéƒ¨ç½²çš„æ›´æ”¹
        if (RED.nodes.dirty()) {
            addMessageToChat("warning", "âš ï¸ æ£€æµ‹åˆ°æœªéƒ¨ç½²çš„æ›´æ”¹ï¼Œè¯·å…ˆç‚¹å‡»éƒ¨ç½²æŒ‰é’®");
            return;
        }

        // è·å–å½“å‰é€‰ä¸­çš„æµç¨‹å’ŒèŠ‚ç‚¹ä¿¡æ¯
        var selectedFlow = null;
        var selectedNodes = [];
        var flowData = null;

        try {
            // è·å–å½“å‰æ´»åŠ¨çš„å·¥ä½œåŒº
            var activeWorkspace = RED.workspaces.active();
            if (activeWorkspace) {
                selectedFlow = {
                    id: activeWorkspace.id,
                    label: activeWorkspace.label || 'Untitled Flow'
                };
                
                // è·å–æµç¨‹æ•°æ®
                flowData = RED.nodes.createExportableNodeSet([activeWorkspace.id]);
            }
            
            // è·å–é€‰ä¸­çš„èŠ‚ç‚¹
            var selection = RED.view.selection();
            if (selection && selection.nodes) {
                selectedNodes = selection.nodes.map(node => ({
                    id: node.id,
                    type: node.type,
                    name: node.name || '',
                    x: node.x,
                    y: node.y,
                    wires: node.wires || [],
                    config: Object.keys(node).reduce((config, key) => {
                        if (!['credentials', 'apiKey', 'password', 'token'].includes(key) && 
                            !key.startsWith('_') && 
                            typeof node[key] !== 'function') {
                            config[key] = node[key];
                        }
                        return config;
                    }, {})
                }));
            }
        } catch (error) {
            console.warn("è·å–é€‰ä¸­ä¿¡æ¯å¤±è´¥:", error);
        }

        console.log("å‘é€AIè¯·æ±‚:", {
            message: message,
            nodeId: nodeId,
            selectedFlow: selectedFlow,
            selectedNodes: selectedNodes,
            flowData: flowData,
            history: getChatHistory()
        });
        
        // åˆ›å»ºåŠ è½½æ¶ˆæ¯
        var loadingMessageId = "loading-" + Date.now();
        var aiMessageId = "ai-" + Date.now(); // å®šä¹‰aiMessageId
        addMessageToChat("assistant", "ğŸ¤– æ€è€ƒä¸­...", loadingMessageId);
        
        // ä½¿ç”¨fetchè¿›è¡Œæµå¼è¯·æ±‚
        fetch('/make-iot-smart/chat-stream', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                message: message,
                nodeId: nodeId,
                selectedFlow: selectedFlow,
                selectedNodes: selectedNodes,
                flowData: flowData,
                history: getChatHistory()
            })
        })
        .then(response => {
            console.log("æ”¶åˆ°å“åº”:", response.status, response.statusText);
            
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            
            const reader = response.body.getReader();
            const decoder = new TextDecoder();
            
            function readStream() {
                return reader.read().then(({ done, value }) => {
                    if (done) {
                        console.log("æµè¯»å–å®Œæˆ");
                        // ç§»é™¤åŠ è½½æ¶ˆæ¯
                        $("#" + loadingMessageId).remove();
                        return;
                    }
                    
                    const chunk = decoder.decode(value, { stream: true });
                    console.log("æ”¶åˆ°æ•°æ®å—:", chunk);
                    
                    const lines = chunk.split('\n');
                    lines.forEach(line => {
                        if (line.startsWith('data: ')) {
                            try {
                                const data = JSON.parse(line.slice(6));
                                console.log("=== è§£æçš„SSEæ•°æ® ===");
                                console.log("æ•°æ®ç±»å‹:", data.type);
                                console.log("å®Œæ•´æ•°æ®:", JSON.stringify(data, null, 2));
                                
                                if (data.type === 'content') {
                                    // ç§»é™¤åŠ è½½æ¶ˆæ¯ï¼ˆå¦‚æœè¿˜å­˜åœ¨ï¼‰
                                    $("#" + loadingMessageId).remove();
                                    
                                    // è¿½åŠ æ–‡æœ¬åˆ°AIæ¶ˆæ¯
                                    var aiMessage = $("#" + aiMessageId + " .message-content");
                                    if (aiMessage.length === 0) {
                                        // å¦‚æœAIæ¶ˆæ¯ä¸å­˜åœ¨ï¼Œåˆ›å»ºå®ƒ
                                        addMessageToChat("assistant", data.content, aiMessageId);
                                    } else {
                                        aiMessage.text(aiMessage.text() + data.content);
                                    }
                                    forceScrollToBottom();
                                } else if (data.type === 'json_editor') {
                                    console.log("=== å¤„ç†json_editor ===");
                                    console.log("ç¼–è¾‘å™¨æ•°æ®:", data);
                                    
                                    // ç¡®ä¿AIæ¶ˆæ¯å­˜åœ¨
                                    var aiMessage = $("#" + aiMessageId);
                                    if (aiMessage.length === 0) {
                                        addMessageToChat("assistant", "", aiMessageId);
                                    }
                                    
                                    // ç§»é™¤åŠ è½½æ¶ˆæ¯
                                    $("#" + loadingMessageId).remove();
                                    
                                    // æ·»åŠ JSONç¼–è¾‘å™¨
                                    addJSONEditor(aiMessageId, data);
                                } else if (data.type === 'action_button') {
                                    console.log("=== å¤„ç†action_button ===");
                                    console.log("æŒ‰é’®æ•°æ®:", data);
                                    
                                    // ç¡®ä¿AIæ¶ˆæ¯å­˜åœ¨
                                    var aiMessage = $("#" + aiMessageId);
                                    if (aiMessage.length === 0) {
                                        addMessageToChat("assistant", "", aiMessageId);
                                    }
                                    
                                    // ç§»é™¤åŠ è½½æ¶ˆæ¯
                                    $("#" + loadingMessageId).remove();
                                    
                                    // æ·»åŠ æŒ‰é’®
                                    addActionButton(aiMessageId, data);
                                } else if (data.type === 'start') {
                                    console.log("AIå¼€å§‹å“åº”, MCPå¯ç”¨:", data.mcpAvailable);
                                    console.log("MCPå·¥å…·æ•°é‡:", data.mcpToolsCount);
                                    
                                    // ç§»é™¤åŠ è½½æ¶ˆæ¯ï¼Œåˆ›å»ºAIæ¶ˆæ¯
                                    $("#" + loadingMessageId).remove();
                                    addMessageToChat("assistant", "", aiMessageId);
                                } else if (data.type === 'end') {
                                    console.log("AIå“åº”ç»“æŸ");
                                    // ç§»é™¤åŠ è½½æ¶ˆæ¯ï¼ˆå¦‚æœè¿˜å­˜åœ¨ï¼‰
                                    $("#" + loadingMessageId).remove();
                                } else if (data.type === 'error') {
                                    $("#" + loadingMessageId).remove();
                                    addMessageToChat("error", "âŒ " + data.content);
                                } else if (data.type === 'tool') {
                                    console.log("æ”¶åˆ°toolä¿¡æ¯:", data);
                                    var aiMessage = $("#" + aiMessageId + " .message-content");
                                    if (aiMessage.length > 0) {
                                        aiMessage.text(aiMessage.text() + "\n\n" + data.content);
                                        forceScrollToBottom();
                                    }
                                }
                            } catch (e) {
                                console.warn("è§£æSSEæ•°æ®å¤±è´¥:", line, e);
                            }
                        }
                    });
                    
                    return readStream();
                });
            }
            
            return readStream();
        })
        .catch(error => {
            console.error("AIè¯·æ±‚å¤±è´¥:", error);
            $("#" + loadingMessageId).remove();
            addMessageToChat("error", "âŒ AIè¯·æ±‚å¤±è´¥: " + error.message);
        });
    }

    function handleStreamData(data, loadingMessageId) {
        switch (data.type) {
            case 'start':
                // ç§»é™¤åŠ è½½æ¶ˆæ¯ï¼Œå¼€å§‹æ˜¾ç¤ºå®é™…å“åº”
                $("#" + loadingMessageId).remove();
                currentStreamMessageId = 'stream-' + Date.now();
                addMessageToChat("assistant", "", currentStreamMessageId);
                break;
                
            case 'text':
            case 'content':
                // è¿½åŠ æ–‡æœ¬å†…å®¹
                if (currentStreamMessageId) {
                    appendToMessage(currentStreamMessageId, data.content);
                }
                break;
                
            case 'action_button':
                // å¤„ç†åŠ¨ä½œæŒ‰é’®
                if (currentStreamMessageId) {
                    addActionButton(currentStreamMessageId, data);
                }
                break;
                
            case 'tool_call':
                // æ˜¾ç¤ºå·¥å…·è°ƒç”¨ä¿¡æ¯
                if (currentStreamMessageId) {
                    var toolInfo = `ğŸ”§ è°ƒç”¨å·¥å…·: ${data.tool_name}\nå‚æ•°: ${JSON.stringify(data.arguments, null, 2)}\n`;
                    appendToMessage(currentStreamMessageId, toolInfo);
                }
                break;
                
            case 'tool_result':
                // æ˜¾ç¤ºå·¥å…·æ‰§è¡Œç»“æœ
                if (currentStreamMessageId) {
                    var resultInfo = `âœ… å·¥å…·æ‰§è¡Œç»“æœ:\n${data.result}\n\n`;
                    appendToMessage(currentStreamMessageId, resultInfo);
                }
                break;
                
            case 'error':
                if (currentStreamMessageId) {
                    appendToMessage(currentStreamMessageId, `âŒ é”™è¯¯: ${data.error}`);
                }
                break;
                
            case 'done':
            case 'end':
                // æµå¼å“åº”å®Œæˆ
                currentStreamMessageId = null;
                saveChatMessage("assistant", data.final_content || "");
                break;
        }
    }

    function appendToMessage(messageId, content) {
        var messageElement = $("#" + messageId + " .message-content");
        if (messageElement.length > 0) {
            var currentContent = messageElement.text();
            messageElement.text(currentContent + content);
            forceScrollToBottom();
        }
    }

    function getSelectedConfigNodeId() {
        // æŸ¥æ‰¾api-configç±»å‹çš„é…ç½®èŠ‚ç‚¹
        var configNodeId = null;
        try {
            RED.nodes.eachConfig(function(configNode) {
                if (configNode.type === 'api-config') {
                    configNodeId = configNode.id;
                    console.log("æ‰¾åˆ°api-configèŠ‚ç‚¹:", configNodeId, configNode);
                    return false; // æ‰¾åˆ°ç¬¬ä¸€ä¸ªå°±åœæ­¢
                }
            });
            
            // å¦‚æœæ²¡æœ‰æ‰¾åˆ°ï¼Œå°è¯•åˆ›å»ºä¸€ä¸ªé»˜è®¤çš„é…ç½®èŠ‚ç‚¹
            if (!configNodeId) {
                console.log("æœªæ‰¾åˆ°api-configèŠ‚ç‚¹ï¼Œå°è¯•åˆ›å»ºé»˜è®¤èŠ‚ç‚¹");
                configNodeId = createDefaultApiConfigNode();
            }
            
            // éªŒè¯èŠ‚ç‚¹æ˜¯å¦çœŸçš„å­˜åœ¨
            if (configNodeId) {
                var node = RED.nodes.node(configNodeId);
                if (!node) {
                    console.warn("èŠ‚ç‚¹IDå­˜åœ¨ä½†æ— æ³•è·å–èŠ‚ç‚¹å®ä¾‹:", configNodeId);
                    return null;
                }
            }
            
        } catch (error) {
            console.warn("è·å–é…ç½®èŠ‚ç‚¹å¤±è´¥:", error);
        }
        return configNodeId;
    }

    function createDefaultApiConfigNode() {
        try {
            // æ£€æŸ¥api-configèŠ‚ç‚¹ç±»å‹æ˜¯å¦å·²æ³¨å†Œ
            var apiConfigNodeType = RED.nodes.getType("api-config");
            if (!apiConfigNodeType) {
                console.error("api-configèŠ‚ç‚¹ç±»å‹æœªæ³¨å†Œ");
                return null;
            }
            
            // åˆ›å»ºé»˜è®¤çš„api-configèŠ‚ç‚¹
            var defaultConfigNode = {
                id: RED.nodes.id(),
                _def: apiConfigNodeType,
                type: "api-config",
                hasUsers: false,
                users: [],
                name: "Default AI Config",
                label: function() { return this.name || "Default AI Config"; },
                provider: "openai",
                model: "gpt-4o-mini",
                temperature: 0.1,
                maxTokens: 2000,
                useDifferentModels: false,
                planningModel: "",
                executionModel: "",
                credentials: {
                    apiKey: "è¯·é…ç½®APIå¯†é’¥" // ä¸´æ—¶å ä½ç¬¦
                }
            };
            
            // æ·»åŠ åˆ°Node-REDèŠ‚ç‚¹é›†åˆ
            RED.nodes.add(defaultConfigNode);
            RED.nodes.dirty(true);
            
            console.log("åˆ›å»ºé»˜è®¤api-configèŠ‚ç‚¹:", defaultConfigNode.id);
            
            // ç«‹å³éƒ¨ç½²ä»¥ç¡®ä¿èŠ‚ç‚¹ä¿å­˜åˆ°åç«¯
            RED.deploy.setDeployInflight(false);
            RED.nodes.dirty(true);
            
            // æç¤ºç”¨æˆ·é…ç½®å¹¶éƒ¨ç½²
            setTimeout(function() {
                RED.notify("å·²åˆ›å»ºé»˜è®¤AIé…ç½®èŠ‚ç‚¹ï¼Œè¯·é…ç½®APIå¯†é’¥å¹¶ç‚¹å‡»éƒ¨ç½²æŒ‰é’®", "info");
                RED.editor.editConfig("", "api-config", defaultConfigNode.id);
            }, 1000);
            
            return defaultConfigNode.id;
        } catch (error) {
            console.error("åˆ›å»ºé»˜è®¤é…ç½®èŠ‚ç‚¹å¤±è´¥:", error);
            return null;
        }
    }

    function getChatHistory() {
        // ä»èŠå¤©è®°å½•ä¸­æå–å†å²æ¶ˆæ¯
        var history = [];
        $("#augment-chat-messages .augment-message-container").each(function() {
            var role = $(this).hasClass("user-message") ? "user" : "assistant";
            var content = $(this).find(".message-content").text().trim();
            if (content && content !== "ğŸ¤– æ­£åœ¨æ€è€ƒ...") {
                history.push({
                    role: role,
                    content: content
                });
            }
        });
        return history.slice(-10); // åªä¿ç•™æœ€è¿‘10æ¡æ¶ˆæ¯
    }

    function saveChatMessage(role, content) {
        // ä¿å­˜æ¶ˆæ¯åˆ°Node-REDçš„å…¨å±€ä¸Šä¸‹æ–‡ï¼ˆå¯é€‰ï¼‰
        try {
            var context = RED.settings.get('contextStorage') || {};
            if (context.default && context.default.module === 'localfilesystem') {
                // å¦‚æœé…ç½®äº†æ–‡ä»¶å­˜å‚¨ï¼Œå¯ä»¥ä¿å­˜èŠå¤©è®°å½•
                console.log("ä¿å­˜èŠå¤©è®°å½•:", role, content);
            }
        } catch (error) {
            console.warn("ä¿å­˜èŠå¤©è®°å½•å¤±è´¥:", error);
        }
    }

    // ä¿®æ”¹addMessageToChatå‡½æ•°ä»¥æ”¯æŒæµå¼æ›´æ–°
    function addMessageToChat(role, messageData, messageId) {
        loadAISidebarConfig().then(function(config) {
            var isUser = role === "user";
            var userLabel = config.ui.userLabel;
            var assistantLabel = config.ui.assistantLabel;
            var label = isUser ? userLabel : assistantLabel;
            
            var timestamp = new Date().toLocaleTimeString('en-US', { 
                hour: '2-digit', 
                minute: '2-digit',
                hour12: true 
            });
            
            var messageHtml = '<div class="augment-message-container ' + (isUser ? 'user-message' : 'assistant-message') + '" ' + 
                             (messageId ? 'id="' + messageId + '"' : '') + ' style="margin: 0 0 24px 0;">';
            
            // æ¶ˆæ¯å¤´éƒ¨
            messageHtml += '<div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">';
            messageHtml += '<div style="width: 24px; height: 24px; border-radius: 50%; background: ' + 
                          (isUser ? '#3b82f6' : '#10b981') + '; display: flex; align-items: center; justify-content: center;">';
            messageHtml += '<span style="color: white; font-size: 12px; font-weight: 600;">' + 
                          (isUser ? 'Y' : 'A') + '</span>';
            messageHtml += '</div>';
            messageHtml += '<span style="font-weight: 600; color: #374151;">' + label + '</span>';
            messageHtml += '<span style="color: #9ca3af; font-size: 12px; margin-left: auto;">' + timestamp + '</span>';
            messageHtml += '</div>';
            
            // æ¶ˆæ¯å†…å®¹
            messageHtml += '<div class="message-content" style="background: ' + (isUser ? '#f3f4f6' : '#ffffff') + 
                          '; padding: 12px 16px; border-radius: 12px; border: 1px solid #e5e7eb; white-space: pre-wrap; word-wrap: break-word;">';
            messageHtml += typeof messageData === 'string' ? messageData : '';
            messageHtml += '</div>';
            messageHtml += '</div>';
            
            $("#augment-chat-messages").append(messageHtml);
            forceScrollToBottom();
        });
    }
    
    function forceScrollToBottom() {
        // æ–¹æ³•1ï¼šä½¿ç”¨jQueryçš„scrollTop
        var chatContainer = $("#augment-chat-messages");
        chatContainer.scrollTop(chatContainer[0].scrollHeight);
        
        // æ–¹æ³•2ï¼šä½¿ç”¨åŸç”ŸJavaScriptçš„scrollTo
        var container = document.getElementById("augment-chat-messages");
        if (container) {
            container.scrollTo(0, container.scrollHeight);
        }
        
        // æ–¹æ³•3ï¼šä½¿ç”¨setTimeoutç¡®ä¿DOMå·²æ›´æ–°
        setTimeout(function() {
            chatContainer.scrollTop(chatContainer[0].scrollHeight);
        }, 50);
    }
    // æ·»åŠ é…ç½®åŠ è½½å‡½æ•°
    function loadAISidebarConfig() {
        return Promise.resolve({
            ui: {
                placeholder: "Ask or instruct Augment",
                currentFlow: "å½“å‰æµç¨‹",
                currentNode: "å½“å‰èŠ‚ç‚¹",
                noFlowSelected: "æœªé€‰æ‹©æµç¨‹",
                noNodeSelected: "æœªé€‰æ‹©èŠ‚ç‚¹",
                multipleNodesSelected: "å·²é€‰æ‹© {count} ä¸ªèŠ‚ç‚¹",
                nodeType: "ç±»å‹",
                timestamp: "07:51 PM",
                userLabel: "You",
                assistantLabel: "Augment"
            },
            messages: {
                developmentInProgress: "æ­¤åŠŸèƒ½æ­£åœ¨å¼€å‘ä¸­",
                simulatedResponse: "è¿™æ˜¯ä¸€ä¸ªæ¨¡æ‹Ÿçš„AIå›å¤ã€‚"
            }
        });
    }
    // æ·»åŠ åŠ¨ä½œæŒ‰é’®åˆ°æ¶ˆæ¯
    function addActionButton(messageId, buttonData) {
        var messageElement = $("#" + messageId);
        if (messageElement.length > 0) {
            console.log("æ·»åŠ æŒ‰é’®åˆ°æ¶ˆæ¯:", messageId, buttonData);
            
            // åˆ›å»ºæŒ‰é’®HTMLï¼Œæ¨¡ä»¿Augment UIé£æ ¼çš„ApplyæŒ‰é’®
            var buttonHtml = `
                <div class="action-button-container" style="
                    margin-top: 16px; 
                    padding: 0;
                    display: flex;
                    justify-content: flex-end;
                ">
                    <button class="execute-tool-btn" 
                            data-tool-name="${buttonData.toolName}" 
                            data-tool-args='${JSON.stringify(buttonData.toolArgs)}'
                            style="
                                background: #10b981;
                                border: 1px solid #10b981;
                                border-radius: 6px;
                                padding: 6px 12px;
                                font-size: 13px;
                                color: white;
                                cursor: pointer;
                                display: inline-flex;
                                align-items: center;
                                gap: 6px;
                                transition: all 0.2s;
                                font-weight: 500;
                                min-width: 60px;
                                justify-content: center;
                            "
                            onmouseover="this.style.background='#059669'"
                            onmouseout="this.style.background='#10b981'">
                        <i class="fa fa-check" style="font-size: 12px;"></i>
                        Apply
                    </button>
                </div>
            `;
            
            messageElement.find('.message-content').append(buttonHtml);
            forceScrollToBottom();
        } else {
            console.warn("æ‰¾ä¸åˆ°æ¶ˆæ¯å…ƒç´ :", messageId);
        }
    }

    // æŒ‰é’®ç‚¹å‡»äº‹ä»¶å¤„ç†
    $(document).on('click', '.execute-tool-btn', function() {
        var toolName = $(this).data('tool-name');
        var toolArgs = $(this).data('tool-args');
        var button = $(this);
        var originalText = button.html();
        
        // è·å–å½“å‰é€‰ä¸­çš„æµç¨‹ä¿¡æ¯
        var selectedFlow = null;
        try {
            var activeWorkspace = RED.workspaces.active();
            if (activeWorkspace) {
                selectedFlow = {
                    id: activeWorkspace,
                    label: RED.nodes.workspace(activeWorkspace).label
                };
            }
        } catch (error) {
            console.warn("è·å–å½“å‰æµç¨‹å¤±è´¥:", error);
        }
        
        // ç¦ç”¨æŒ‰é’®å¹¶æ˜¾ç¤ºåŠ è½½çŠ¶æ€
        button.prop('disabled', true)
              .html('<i class="fa fa-spinner fa-spin" style="font-size: 12px;"></i> æ‰§è¡Œä¸­...')
              .css({
                  'background': '#f3f4f6',
                  'color': '#6b7280',
                  'cursor': 'not-allowed'
              });
        
        // è·å–é…ç½®èŠ‚ç‚¹ID
        var nodeId = getSelectedConfigNodeId();
        if (!nodeId) {
            addMessageToChat("error", "âŒ æœªæ‰¾åˆ°é…ç½®èŠ‚ç‚¹ï¼Œè¯·å…ˆåˆ›å»ºå¹¶é…ç½®APIå¯†é’¥");
            button.prop('disabled', false).html(originalText);
            return;
        }
        
        console.log('æ‰§è¡Œå·¥å…·è°ƒç”¨:', toolName, toolArgs, 'å½“å‰æµç¨‹:', selectedFlow);
        
        // å‘é€å·¥å…·æ‰§è¡Œè¯·æ±‚
        $.ajax({
            url: '/make-iot-smart/execute-tool',
            method: 'POST',
            contentType: 'application/json',
            data: JSON.stringify({
                toolName: toolName,
                toolArgs: toolArgs,
                nodeId: nodeId,
                selectedFlow: selectedFlow
            }),
            success: function(response) {
                if (response.success) {
                    // æ˜¾ç¤ºæ‰§è¡ŒæˆåŠŸ
                    button.html('<i class="fa fa-check" style="font-size: 12px;"></i> å·²å®Œæˆ')
                          .css({
                              'background': '#dcfce7',
                              'color': '#166534',
                              'border-color': '#bbf7d0'
                          });
                    
                    // æ·»åŠ æˆåŠŸæ¶ˆæ¯
                    addMessageToChat("assistant", `âœ… ${toolName} æ‰§è¡ŒæˆåŠŸï¼\n\n${response.result}`);
                } else {
                    // æ˜¾ç¤ºæ‰§è¡Œå¤±è´¥
                    button.prop('disabled', false)
                          .html('<i class="fa fa-exclamation-triangle" style="font-size: 12px;"></i> é‡è¯•')
                          .css({
                              'background': '#fef2f2',
                              'color': '#dc2626',
                              'border-color': '#fecaca'
                          });
                    
                    addMessageToChat("error", `âŒ æ‰§è¡Œå¤±è´¥: ${response.error}`);
                }
            },
            error: function(xhr) {
                var error = xhr.responseJSON ? xhr.responseJSON.error : 'ç½‘ç»œé”™è¯¯';
                
                // æ¢å¤æŒ‰é’®çŠ¶æ€
                button.prop('disabled', false)
                      .html('<i class="fa fa-exclamation-triangle" style="font-size: 12px;"></i> é‡è¯•')
                      .css({
                          'background': '#fef2f2',
                          'color': '#dc2626',
                          'border-color': '#fecaca'
                      });
                
                addMessageToChat("error", `âŒ æ‰§è¡Œå¤±è´¥: ${error}`);
            }
        });
    });
    // æ·»åŠ JSONç¼–è¾‘å™¨åˆ°æ¶ˆæ¯
    function addJSONEditor(messageId, editorData) {
        console.log("=== addJSONEditor è¢«è°ƒç”¨ ===");
        console.log("messageId:", messageId);
        console.log("editorData:", editorData);
        
        var messageElement = $("#" + messageId);
        console.log("æ‰¾åˆ°æ¶ˆæ¯å…ƒç´ :", messageElement.length > 0);
        
        if (messageElement.length > 0) {
            var editorId = "json-editor-" + Date.now();
            
            // åˆ›å»ºç¼–è¾‘å™¨HTML
            var editorHtml = `
                <div class="json-editor-container" style="margin-top: 16px;">
                    <div style="margin-bottom: 8px;">
                        <strong>${editorData.editorTitle || 'æµç¨‹é…ç½®'}</strong>
                    </div>
                    <div style="margin-bottom: 12px; color: #6b7280; font-size: 14px;">
                        ${editorData.description || ''}
                    </div>
                    <div id="${editorId}" style="
                        height: 300px;
                        border: 1px solid #e5e7eb;
                        border-radius: 6px;
                        margin-bottom: 12px;
                    "></div>
                    <div style="display: flex; justify-content: flex-end; gap: 8px;">
                        <button class="json-editor-apply-btn" 
                                data-editor-id="${editorId}"
                                data-tool-name="${editorData.toolName}" 
                                data-tool-args='${JSON.stringify(editorData.toolArgs)}'
                                style="
                                    background: #10b981;
                                    border: 1px solid #10b981;
                                    border-radius: 6px;
                                    padding: 8px 16px;
                                    font-size: 14px;
                                    color: white;
                                    cursor: pointer;
                                    display: inline-flex;
                                    align-items: center;
                                    gap: 6px;
                                    transition: all 0.2s;
                                    font-weight: 500;
                                "
                                onmouseover="this.style.background='#059669'"
                                onmouseout="this.style.background='#10b981'">
                            <i class="fa fa-check" style="font-size: 12px;"></i>
                            Apply
                        </button>
                    </div>
                </div>
            `;
            
            console.log("æ·»åŠ ç¼–è¾‘å™¨HTML");
            messageElement.find('.message-content').append(editorHtml);
            
            // åˆå§‹åŒ–JSONç¼–è¾‘å™¨
            ensureAceEditorLoaded(function() {
                initializeJSONEditor(editorId, editorData.jsonContent);
            });
            
            // æ·»åŠ ApplyæŒ‰é’®ç‚¹å‡»äº‹ä»¶
            messageElement.find('.json-editor-apply-btn').off('click').on('click', function() {
                console.log("JSONç¼–è¾‘å™¨ApplyæŒ‰é’®è¢«ç‚¹å‡»");
                var editorId = $(this).data('editor-id');
                var toolName = $(this).data('tool-name');
                var originalToolArgs = $(this).data('tool-args');
                
                // è·å–ç¼–è¾‘å™¨å†…å®¹
                var editor = window.jsonEditors && window.jsonEditors[editorId];
                if (!editor) {
                    RED.notify("ç¼–è¾‘å™¨æœªæ‰¾åˆ°", "error");
                    return;
                }
                
                var editedContent = editor.getValue();
                
                // éªŒè¯JSONæ ¼å¼
                try {
                    var parsedJson = JSON.parse(editedContent);
                    
                    // æ›´æ–°å·¥å…·å‚æ•°
                    var updatedToolArgs = Object.assign({}, originalToolArgs);
                    if (toolName === 'create-flow') {
                        updatedToolArgs.flowJson = editedContent;
                    }
                    
                    console.log("æ‰§è¡Œå·¥å…·:", toolName, updatedToolArgs);
                    
                    // ç¦ç”¨æŒ‰é’®
                    $(this).prop('disabled', true)
                           .html('<i class="fa fa-spinner fa-spin" style="font-size: 12px;"></i> æ‰§è¡Œä¸­...')
                           .css({
                               'background': '#f3f4f6',
                               'color': '#6b7280',
                               'cursor': 'not-allowed'
                           });
                    
                    // è°ƒç”¨æ‰§è¡Œå·¥å…·çš„API
                    executeJSONEditorTool(toolName, updatedToolArgs, $(this));
                    
                } catch (e) {
                    RED.notify("JSONæ ¼å¼é”™è¯¯: " + e.message, "error");
                    // é«˜äº®é”™è¯¯è¡Œ
                    document.getElementById(editorId).style.borderColor = '#dc3545';
                }
            });
            
            forceScrollToBottom();
            console.log("JSONç¼–è¾‘å™¨æ·»åŠ å®Œæˆ");
        } else {
            console.error("æ‰¾ä¸åˆ°æ¶ˆæ¯å…ƒç´ :", messageId);
        }
    }
    
    // æ‰§è¡ŒJSONç¼–è¾‘å™¨çš„å·¥å…·è°ƒç”¨
    function executeJSONEditorTool(toolName, toolArgs, buttonElement) {
        console.log("æ‰§è¡ŒJSONç¼–è¾‘å™¨å·¥å…·è°ƒç”¨:", toolName, toolArgs);
        
        var nodeId = getSelectedConfigNodeId();
        if (!nodeId) {
            addMessageToChat("error", "âŒ æœªæ‰¾åˆ°é…ç½®èŠ‚ç‚¹ï¼Œè¯·å…ˆåˆ›å»ºå¹¶é…ç½®APIå¯†é’¥");
            buttonElement.prop('disabled', false).html('<i class="fa fa-check"></i> Apply');
            return;
        }
        
        var selectedFlow = null;
        try {
            var activeWorkspace = RED.workspaces.active();
            if (activeWorkspace) {
                selectedFlow = {
                    id: activeWorkspace,
                    label: RED.nodes.workspace(activeWorkspace).label
                };
            }
        } catch (error) {
            console.warn("è·å–å½“å‰æµç¨‹å¤±è´¥:", error);
        }
        
        fetch('/make-iot-smart/execute-tool', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                toolName: toolName,
                toolArgs: toolArgs,
                nodeId: nodeId,
                selectedFlow: selectedFlow
            })
        })
        .then(response => response.json())
        .then(data => {
            console.log("å·¥å…·æ‰§è¡Œç»“æœ:", data);
            
            if (data.success) {
                // æˆåŠŸæ‰§è¡Œ
                buttonElement.removeClass('execute-tool-btn')
                    .css({
                        'background': '#059669',
                        'cursor': 'default'
                    })
                    .html('<i class="fa fa-check"></i> å·²åº”ç”¨')
                    .prop('disabled', true);
                
                // æ˜¾ç¤ºæˆåŠŸæ¶ˆæ¯
                addMessageToChat("system", "âœ… æµç¨‹åˆ›å»ºæˆåŠŸï¼");
                
                // å¯é€‰ï¼šåˆ·æ–°é¡µé¢æˆ–æ›´æ–°æµç¨‹åˆ—è¡¨
                if (typeof RED !== 'undefined' && RED.view) {
                    RED.view.redraw();
                }
            } else {
                // æ‰§è¡Œå¤±è´¥
                buttonElement.prop('disabled', false)
                    .css('background', '#ef4444')
                    .text('æ‰§è¡Œå¤±è´¥');
                
                addMessageToChat("error", "âŒ å·¥å…·æ‰§è¡Œå¤±è´¥: " + data.error);
                
                // 3ç§’åæ¢å¤æŒ‰é’®
                setTimeout(() => {
                    buttonElement.css('background', '#10b981').text('Apply');
                }, 3000);
            }
        })
        .catch(error => {
            console.error("å·¥å…·æ‰§è¡Œé”™è¯¯:", error);
            buttonElement.prop('disabled', false)
                      .html('<i class="fa fa-exclamation-triangle" style="font-size: 12px;"></i> é‡è¯•')
                      .css({
                          'background': '#fef2f2',
                          'color': '#dc2626',
                          'border-color': '#fecaca'
                      });
            
            addMessageToChat("error", "âŒ ç½‘ç»œé”™è¯¯: " + error.message);
        });
    }
    // å…¨å±€å‡½æ•°å®šä¹‰ - å¿…é¡»åœ¨æœ€å¼€å§‹
    function ensureAceEditorLoaded(callback) {
        if (typeof ace !== 'undefined') {
            callback();
            return;
        }
        
        // å¦‚æœACEæœªåŠ è½½ï¼Œå°è¯•ä»Node-REDåŠ è½½
        if (RED && RED.editor && RED.editor.ace) {
            window.ace = RED.editor.ace;
            callback();
            return;
        }
        
        // æœ€åçš„é™çº§æ–¹æ¡ˆ
        console.warn("ACEç¼–è¾‘å™¨æœªæ‰¾åˆ°ï¼Œå°†ä½¿ç”¨æ™®é€šæ–‡æœ¬æ˜¾ç¤º");
        callback();
    }

    function initializeJSONEditor(editorId, jsonContent) {
        try {
            // éªŒè¯JSONæ ¼å¼
            var parsedJSON;
            try {
                parsedJSON = JSON.parse(jsonContent);
            } catch (e) {
                console.error("JSONæ ¼å¼é”™è¯¯:", e);
                // å¦‚æœä¸æ˜¯æœ‰æ•ˆJSONï¼Œæ˜¾ç¤ºä¸ºæ™®é€šæ–‡æœ¬
                document.getElementById(editorId).innerHTML = '<pre style="padding: 12px; margin: 0; background: #f8f9fa; color: #495057; white-space: pre-wrap; word-wrap: break-word;">' + jsonContent + '</pre>';
                return;
            }
            
            // åˆ›å»ºACEç¼–è¾‘å™¨
            var editor = ace.edit(editorId);
            editor.setTheme("ace/theme/textmate");
            editor.session.setMode("ace/mode/json");
            editor.setValue(JSON.stringify(parsedJSON, null, 2), -1);
            
            // è®¾ç½®ç¼–è¾‘å™¨é€‰é¡¹
            editor.setOptions({
                fontSize: 13,
                showPrintMargin: false,
                highlightActiveLine: true,
                showGutter: true,
                readOnly: false,
                maxLines: 20,
                minLines: 10,
                wrap: true,
                autoScrollEditorIntoView: true
            });
            
            // å­˜å‚¨ç¼–è¾‘å™¨å®ä¾‹ä»¥ä¾¿åç»­æ“ä½œ
            window.jsonEditors = window.jsonEditors || {};
            window.jsonEditors[editorId] = editor;
            
            // ç›‘å¬å†…å®¹å˜åŒ–
            editor.session.on('change', function() {
                try {
                    var content = editor.getValue();
                    JSON.parse(content); // éªŒè¯JSONæ ¼å¼
                    // å¦‚æœJSONæœ‰æ•ˆï¼Œç§»é™¤é”™è¯¯æ ·å¼
                    document.getElementById(editorId).style.borderColor = '#e9ecef';
                } catch (e) {
                    // å¦‚æœJSONæ— æ•ˆï¼Œæ·»åŠ é”™è¯¯æ ·å¼
                    document.getElementById(editorId).style.borderColor = '#dc3545';
                }
            });
            
        } catch (error) {
            console.error("åˆå§‹åŒ–JSONç¼–è¾‘å™¨å¤±è´¥:", error);
            // é™çº§æ˜¾ç¤ºä¸ºæ™®é€šä»£ç å—
            document.getElementById(editorId).innerHTML = '<pre style="padding: 12px; margin: 0; background: #f8f9fa; color: #495057; white-space: pre-wrap; word-wrap: break-word;">' + jsonContent + '</pre>';
        }
    }

    function copyEditorContent(editorId) {
        try {
            var editor = window.jsonEditors && window.jsonEditors[editorId];
            var content;
            
            if (editor) {
                content = editor.getValue();
            } else {
                // é™çº§æ–¹æ¡ˆï¼šä»DOMè·å–å†…å®¹
                var element = document.getElementById(editorId);
                content = element.textContent || element.innerText;
            }
            
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(content).then(function() {
                    RED.notify("å†…å®¹å·²å¤åˆ¶åˆ°å‰ªè´´æ¿", "success");
                }).catch(function(err) {
                    console.error('å¤åˆ¶å¤±è´¥:', err);
                    fallbackCopyTextToClipboard(content);
                });
            } else {
                fallbackCopyTextToClipboard(content);
            }
        } catch (error) {
            console.error("å¤åˆ¶ç¼–è¾‘å™¨å†…å®¹æ—¶å‡ºé”™:", error);
            RED.notify("å¤åˆ¶å¤±è´¥: " + error.message, "error");
        }
    }

    function applyEditorContent(editorId) {
        try {
            var editor = window.jsonEditors && window.jsonEditors[editorId];
            if (!editor) {
                RED.notify("ç¼–è¾‘å™¨æœªæ‰¾åˆ°", "error");
                return;
            }
            
            var content = editor.getValue();
            
            // éªŒè¯JSONæ ¼å¼
            try {
                JSON.parse(content);
                RED.notify("JSONæ ¼å¼æœ‰æ•ˆï¼Œå†…å®¹å·²åº”ç”¨", "success");
                
                // è¿™é‡Œå¯ä»¥æ·»åŠ å®é™…çš„åº”ç”¨é€»è¾‘ï¼Œæ¯”å¦‚ï¼š
                // - ä¿å­˜åˆ°é…ç½®æ–‡ä»¶
                // - æ›´æ–°Node-REDé…ç½®
                // - å‘é€åˆ°åç«¯APIç­‰
                
            } catch (e) {
                RED.notify("JSONæ ¼å¼é”™è¯¯: " + e.message, "error");
            }
            
        } catch (error) {
            console.error("åº”ç”¨ç¼–è¾‘å™¨å†…å®¹æ—¶å‡ºé”™:", error);
            RED.notify("åº”ç”¨å¤±è´¥: " + error.message, "error");
        }
    }

    function fallbackCopyTextToClipboard(text) {
        var textArea = document.createElement("textarea");
        textArea.value = text;
        
        // é¿å…æ»šåŠ¨åˆ°åº•éƒ¨
        textArea.style.top = "0";
        textArea.style.left = "0";
        textArea.style.position = "fixed";
        
        document.body.appendChild(textArea);
        textArea.focus();
        textArea.select();
        
        try {
            var successful = document.execCommand('copy');
            if (successful) {
                RED.notify("å†…å®¹å·²å¤åˆ¶åˆ°å‰ªè´´æ¿", "success");
            } else {
                RED.notify("å¤åˆ¶å¤±è´¥", "error");
            }
        } catch (err) {
            console.error('é™çº§å¤åˆ¶æ–¹æ¡ˆå¤±è´¥:', err);
            RED.notify("å¤åˆ¶å¤±è´¥", "error");
        }
        
        document.body.removeChild(textArea);
    }

// ä¸»è¦çš„ä»£ç é€»è¾‘
(function() {
    var globalAutoLayoutConfigNode = null;
    function createConfigNodeClickHandler(nodeId) {
        return function(e) {
            e.preventDefault();
            e.stopPropagation();
            
            // é€šè¿‡IDè·å–èŠ‚ç‚¹
            var node = RED.nodes.node(nodeId);
            if (node) {
                // åœ¨ä¾§è¾¹æ ä¸­é€‰ä¸­è¯¥èŠ‚ç‚¹
                $(this).addClass("selected");
                
                // åœ¨ä¿¡æ¯ä¾§è¾¹æ ä¸­æ˜¾ç¤ºèŠ‚ç‚¹ä¿¡æ¯
                RED.sidebar.info.refresh(node);
                
                // æ‰“å¼€é…ç½®å¯¹è¯æ¡†
                RED.editor.editConfig("", node.type, node.id);
            }
        };
    }

    // å°†æ­¤å‡½æ•°æ·»åŠ åˆ°æ˜¾ç¤ºé…ç½®èŠ‚ç‚¹çš„UIç»„ä»¶ä¸­
    function addConfigNodeToList(node) {
        var nodeDiv = $('<div class="config-node-item"></div>');
        
        // æ·»åŠ èŠ‚ç‚¹æ ‡ç­¾
        var labelText = RED.utils.getNodeLabel(node, node.id);
        var label = $('<div class="config-node-label"></div>').text(labelText);
        nodeDiv.append(label);
        
        // æ·»åŠ ç‚¹å‡»å¤„ç†å™¨
        nodeDiv.on('click', createConfigNodeClickHandler(node.id));
        
        // æ·»åŠ åŒå‡»å¤„ç†å™¨ï¼ˆæ›¿ä»£æ–¹æ³•ï¼‰
        nodeDiv.on('dblclick', function(e) {
            e.stopPropagation();
            RED.editor.editConfig("", node.type, node.id);
        });
        
        return nodeDiv;
    }

    function findSelectedNodes(/*thisNode*/) {
        /*
         * Take the selection and create a nodeset from it.
         */
        var selection = RED.view.selection();
        var fixedNodeId = undefined;
        var ns = undefined;

        if (!selection.nodes || selection.nodes.length == 0) {
            RED.notify("Select exactly one node.");
            return;
        }

        if ( selection.nodes.length == 1 ) {
            // This is not applicable for the sidebar plugin
            //if (selection.nodes[0].id == thisNode.id || selection.nodes[0].type == thisNode.type) {
            //    RED.notify("Please do not select the align node.");
            //    return;
            //}

            if ( selection.nodes[0].type == "group") {
                ns = RED.group.getNodes(selection.nodes[0])
                if ( ns.length == 0 ) {
                    RED.notify("Empty group selected, very funny.");
                    return;
                }
                fixedNodeId = ns[0].id;
            } else {
                ns = RED.nodes.getAllFlowNodes(selection.nodes[0])
                fixedNodeId = selection.nodes[0].id;
            }
        }

        if ( selection.nodes.length > 1 ) {
            ns = []
            for ( var idx = 0 ; idx < selection.nodes.length ; idx++ ) {
                if ( selection.nodes[idx].type == "group") {
                    ns = ns.concat(RED.group.getNodes(selection.nodes[idx]))
                } else {
                    ns.push(selection.nodes[idx])
                    fixedNodeId ||= selection.nodes[idx].id;
                }
          }

          fixedNodeId ||= ns[0].id;
        }

        if ( !ns ) {
            RED.notify("No nodes selected.");
            return;
        }

        /* 
         * From here it's all nodeset based.
         */

        // Convert nodes to flows.json format since all the wires, i.e. links, are 
        // contained in one simple json format.
        let fixedNode = RED.nodes.node(fixedNodeId)
        var allnodes = RED.nodes.createExportableNodeSet(ns).filter((n) => {
            return n.type != "tab" && n.type != 'subflow' && n.type != "group" && n.z == fixedNode.z
        });

        var alledges = [];
        var allNodeIds = allnodes.map( d => d.id);

        allnodes.forEach((n) => {
            // Only continue if the node has wires (e.g. a ui_group has no wires)
            if (n.wires) {
                for (var widx = 0; widx < (n.wires || []).length; widx++) {
                    for (var xidx = 0; xidx < n.wires[widx].length; xidx++) {
                        if ( allNodeIds.indexOf(n.wires[widx][xidx])> -1){
                            alledges.push({
                                id: n.id + n.wires[widx][xidx],
                                sources: [n.id],
                                targets: [n.wires[widx][xidx]]
                            });
                        }
                    }
                }
            }
        })

        allnodes = allnodes.map((n) => {
            let bbox = ( ( document.getElementById(n.id) && document.getElementById(n.id).getBBox && document.getElementById(n.id) ) || {
              getBBox: () => {
                return {
                  width: 0,
                  height: 0
                }
              }
            });

            return {
                id: n.id,
                width: bbox.getBBox().width + 3,
                height: bbox.getBBox().height + 3,
            }
        });

        return {
            allnodes: allnodes,
            alledges: alledges,
            fixedNodeId: fixedNodeId
        };
    }
    
    function moveNodes(fixedNodeId, children) {
        //var children = payload.nodes;
        //var fixedNodeId = payload.fixedNodeId;

        var changedNodes = [];

        // Before moving anything we get the offset (x,y) - this is the amount that our
        // fixed Node moved - our fixed node does not move, this means everything is offset
        // by the distance it moved.
        var offsetX = 0;
        var offsetY = 0;
        children.forEach((c) => {
            if (c.id == fixedNodeId) {
                var nd = RED.nodes.node(c.id) || RED.nodes.junction(c.id);
                offsetX = c.x - nd.x;
                offsetY = c.y - nd.y;
            }
        });

        children.forEach((c) => {
            var nd = RED.nodes.node(c.id) || RED.nodes.junction(c.id);

            changedNodes.push({
                n: nd,
                ox: nd.x,
                oy: nd.y,
                moved: nd.moved
            });

            nd.x = c.x - offsetX;
            nd.y = c.y - offsetY;
            nd.dirty = true;
        });

        RED.history.push({ t: "move", nodes: changedNodes, dirty: RED.nodes.dirty() });
        RED.nodes.dirty(true);
        RED.view.redraw(true);
    }
    
    function getDefaultSettings() {
        return {
            "dagre_lr": {
                "rankdir": "LR",
                "marginx": 20,
                "marginy": 20,
                "nodesep": 30,
                "ranksep": 50
            },
            "dagre_longest_path": {
                "rankdir": "LR",
                "marginx": 2,
                "marginy": 2,
                "ranker": "longest-path",
                "nodesep": 2,
                "ranksep": 2
            },
            "elkjs_mr_tree": {
                "algorithm": "mrtree",
                "childAreaHeight": 4500,
                "childAreaWidth": 4500,
                "org.eclipse.elk.direction": "RIGHT"
            },
            "elkjs_layered_upwards": {
                "algorithm": "org.eclipse.elk.layered",
                "elk.direction": "UP",
                "cycleBreaking.strategy": "INTERACTIVE",
                "layering.strategy": "INTERACTIVE",
                "crossingMinimization.semiInteractive": true,
                "separateConnectedComponents": true,
                "nodePlacement.strategy": "NETWORK_SIMPLEX",
                "spacing.nodeNode": 70,
                "spacing.nodeNodeBetweenLayers": 25,
                "spacing.edgeNode": 25,
                "spacing.edgeNodeBetweenLayers": 20,
                "spacing.edgeEdge": 20,
                "spacing.edgeEdgeBetweenLayers": 15,
                "elk.hierarchyHandling": "INCLUDE_CHILDREN",
                "elk.layered.spacing.edgeNodeBetweenLayers": 40,
                "elk.layered.nodePlacement.bk.fixedAlignment": "BALANCED",
                "layering.layerConstraint": "FIRST"
            },
            "elkjs_layered_downwards": {
                "algorithm": "org.eclipse.elk.layered",
                "elk.direction": "DOWN",
                "cycleBreaking.strategy": "INTERACTIVE",
                "layering.strategy": "INTERACTIVE",
                "crossingMinimization.semiInteractive": true,
                "separateConnectedComponents": true,
                "nodePlacement.strategy": "NETWORK_SIMPLEX",
                "spacing.nodeNode": 70,
                "spacing.nodeNodeBetweenLayers": 25,
                "spacing.edgeNode": 25,
                "spacing.edgeNodeBetweenLayers": 20,
                "spacing.edgeEdge": 20,
                "spacing.edgeEdgeBetweenLayers": 15
            },
            "elkjs_box": {
                "algorithm": "org.eclipse.elk.box",
                "org.eclipse.elk.spacing.nodeNode": 20
            },
            "pull_request_2267": {
                // TODO
            }
        }
    }
  
    // Ensure that the globalAutoLayoutConfigNode (still) exists, because the user might have deleted it meanwhile...
    // !!!!!!!!!!!!!!! CALL THIS FUNCTION EVERYWHERE THE globalAutoLayoutConfigNode IS BEING USED !!!!!!!!!!!!!!!
    function ensureAutoLayoutConfigNode() {
        // å¦‚æœæˆ‘ä»¬ä¹‹å‰æ‰¾åˆ°äº†å®ƒï¼Œæ£€æŸ¥ç”¨æˆ·æ˜¯å¦åœ¨æˆ‘ä»¬ä¸çŸ¥æƒ…çš„æƒ…å†µä¸‹åˆ é™¤äº†å®ƒ
        if (globalAutoLayoutConfigNode !== null) {
            var configNode = RED.nodes.node(globalAutoLayoutConfigNode.id);
            if (configNode === null) { globalAutoLayoutConfigNode = null; }
        }

        // å¦‚æœä¹‹å‰æ²¡æœ‰æ‰¾åˆ°ï¼Œè®©æˆ‘ä»¬å»æ‰¾å®ƒ
        if (globalAutoLayoutConfigNode === null) {
            var configNodes = [];
            RED.nodes.eachConfig(function(configNode) {
                if (configNode.type === 'make-iot-smart') { 
                    configNodes.push(configNode); 
                }
            });

            // ç¡®ä¿æˆ‘ä»¬åªæœ‰1ä¸ªé…ç½®èŠ‚ç‚¹
            while (configNodes.length > 1) {
                var configNode = configNodes.pop();
                RED.nodes.remove(configNode.id);
                RED.nodes.dirty(true);
            }

            // å½“æˆ‘ä»¬æ‰¾åˆ°ä¸€ä¸ªé…ç½®èŠ‚ç‚¹æ—¶ï¼Œè®©æˆ‘ä»¬ä½¿ç”¨å®ƒ
            if (configNodes.length === 1) { globalAutoLayoutConfigNode = configNodes[0]; }
        }

        // å½“å®ƒè¿˜ä¸å­˜åœ¨æ—¶ï¼Œå¦‚æœéœ€è¦åˆ™åˆ›å»ºå®ƒ
        if (globalAutoLayoutConfigNode === null) {
            try {
                // æ£€æŸ¥RED.nodes.getTypeæ˜¯å¦è¿”å›æœ‰æ•ˆå€¼
                var nodeType = RED.nodes.getType("make-iot-smart");
                if (!nodeType) {
                    console.error("æ— æ³•æ‰¾åˆ°make-iot-smartèŠ‚ç‚¹ç±»å‹");
                    RED.notify("æ— æ³•æ‰¾åˆ°make-iot-smartèŠ‚ç‚¹ç±»å‹", "error");
                    return;
                }
                
                // åˆ›å»ºé…ç½®èŠ‚ç‚¹
                globalAutoLayoutConfigNode = {
                    id: RED.nodes.id(),
                    _def: nodeType,
                    type: "make-iot-smart",
                    hasUsers: false, 
                    users: [],
                    name: "AutoLayout",
                    label: function() { return this.name || "AutoLayout"},
                    algorithm: "dagre_lr", // é»˜è®¤ç®—æ³•
                    settings: JSON.stringify(getDefaultSettings()) // ä»é»˜è®¤è®¾ç½®å¼€å§‹
                };

                // å°†æ–°çš„é…ç½®èŠ‚ç‚¹æ·»åŠ åˆ°Node-REDèŠ‚ç‚¹é›†åˆä¸­
                RED.nodes.add(globalAutoLayoutConfigNode);

                // ç¡®ä¿"éƒ¨ç½²"æŒ‰é’®å˜ä¸ºæ´»åŠ¨çŠ¶æ€
                RED.nodes.dirty(true);
            } catch (error) {
                console.error("åˆ›å»ºé…ç½®èŠ‚ç‚¹æ—¶å‡ºé”™:", error);
                RED.notify("åˆ›å»ºé…ç½®èŠ‚ç‚¹æ—¶å‡ºé”™: " + error.message, "error");
                return;
            }
        }
    }

    function executeAutoLayout() {
        console.log("Executing auto-layout");
        ensureAutoLayoutConfigNode();

        let currentAlgorithm = globalAutoLayoutConfigNode.algorithm;
        let currentAlgorithmSettings = JSON.parse(globalAutoLayoutConfigNode.settings)[currentAlgorithm];

        let selection = findSelectedNodes();

        if (!selection) {
            return;
        }

        switch(currentAlgorithm) {
            case "dagre_lr":
            case "dagre_longest_path":
                // Code take from https://pastebin.com/TJRFD3mg
                // Which came from https://discourse.nodered.org/t/read-flows-json-and-position-the-nodes-in-most-efficient-readable-way/78158/12
                var g = new dagre.graphlib.Graph();
                g.setGraph(currentAlgorithmSettings);
                g.setDefaultEdgeLabel(function () { return {}; });                       

                for (var idx = 0; idx < selection.allnodes.length; idx++) {
                    var n = selection.allnodes[idx];
                    g.setNode(n.id, {
                        ...n,
                    })
                }
                
                // The above loop can be replaced by :
                // for (var idx = 0; idx < selection.allnodes.length; idx++) {
                //     var node = selection.allnodes[idx];
                //     var clonedNode = Object.assign({}, node);
                //     g.setNode(n.id, clonedNode);
                // }


                for (var idx = 0; idx < selection.alledges.length; idx++) {
                    var e = selection.alledges[idx];
                    g.setEdge(e.sources[0], e.targets[0])
                }

                dagre.layout(g);
                
                var nodes = g.nodes().map(function (v) {
                     return {
                          ...g.node(v)
                        }
                })   
                
                try {
                    moveNodes(selection.fixedNodeId, nodes);
                } catch ( ex ) {
                    console.error( "Dagre exception moving nodes", ex)
                    // ensure that dagre errors are also shown as notifications in Node-RED.
                    RED.notify("Dagre autoroute error: " + ex);
                }
                break;
            case "elkjs_mr_tree": 
            case "elkjs_layered_upwards": 
            case "elkjs_layered_downwards": 
            case "elkjs_box": 
                // see https://github.com/kieler/elkjs#api for more details
                var graph = {
                    id: "root",
                    layoutOptions: currentAlgorithmSettings,
                    children: selection.allnodes,
                    edges: selection.alledges
                };

                const elk = new ELK();

                elk.layout(graph)
                    .then((g) => {
                        moveNodes(selection.fixedNodeId, g.children);
                    })
                    .catch((ex) => {
                        console.error( "ELKjs exception moving nodes", ex)
                        RED.notify("ElkJs autoroute error: " + ex);
                    });
                break;
            
            case "pull_request_2267": 
                // Code Taken from https://github.com/node-red/node-red/pull/2267/files
                // I only replaced 'selection' by 'selection_', but it would be better to use the above 'selection' variable.
                var selection_ = RED.view.selection();
                
                if (!selection_.nodes || selection_.nodes.length !== 1) {
                    RED.notify("Select exactly one node");
                    return;
                }
                
                var ns = undefined;
                if (selection_.nodes[0].type == "group") {
                    ns = RED.group.getNodes(selection_.nodes[0])
                } else {
                    ns = RED.nodes.getAllFlowNodes(selection_.nodes[0]);
                }

                // Find Input node

                var nodes = {};
                var minRank = 0;
                var stack = [];
                var candidateInputs = {};
                var candidateOutputs = {};
                ns.forEach(function (n) {
                    candidateInputs[n.id] = n;
                    candidateOutputs[n.id] = n;
                    nodes[n.id] = {
                        n: n,
                        i: [],
                        o: [],
                        d: -1, // depth from start
                        r: -1, // rank order at that depth
                        downstream: 0
                    }
                });
                RED.nodes.eachLink(function (link) {
                    if (nodes[link.source.id] || nodes[link.target.id]) {
                        nodes[link.source.id].o.push(link.target.id);
                        nodes[link.target.id].i.push(link.source.id);
                        delete candidateInputs[link.target.id]
                        delete candidateOutputs[link.source.id]
                    }
                })

                var inputs = Object.keys(candidateInputs);
                var outputs = Object.keys(candidateOutputs);

                if (inputs.length > 1) {
                    RED.notify("Multiple start points - bailing")
                    return;
                }

                if (outputs.length === 0) {
                    RED.notify("No outputs - is this a big loop? Bailing");
                    return;
                }

                function applyDepth(id, d) {
                    if (nodes[id].d < d) {
                        nodes[id].d = d;
                        nodes[id].o.forEach(function (nid) {
                            applyDepth(nid, d + 1);
                        })
                    }
                }
                applyDepth(inputs[0], 0)

                function calculateDownstream(id, downstream) {
                    nodes[id].downstream += downstream;
                    nodes[id].i.forEach(function (nid) {
                        calculateDownstream(nid, nodes[id].downstream + 1);
                    })
                }
                outputs.forEach(function (id) {
                    calculateDownstream(id, 0)
                })

                var ranks = {};
                function rankNodes(node) {
                    if (node.r === -1) {
                        ranks[node.d] = ranks[node.d] || [];
                        node.r = ranks[node.d].length;
                        ranks[node.d].push(node);
                        node.o.sort(function (a, b) {
                            return nodes[b].downstream - nodes[a].downstream
                        })
                        node.o.forEach(function (nid) {
                            rankNodes(nodes[nid])
                        })
                    }
                }
                rankNodes(nodes[inputs[0]]);
                function shuffleRanks(node) {
                    var pushed = false;
                    if (node.o.length > 1) {
                        var outputs = node.o.slice(0);
                        outputs.sort(function (a, b) {
                            if (nodes[a].d === nodes[b].d) {
                                return nodes[a].r - nodes[b].r;
                            } else {
                                return nodes[b].d - nodes[a].d;
                            }
                        })
                        // outputs.forEach(function(o,i) { console.log(" ",i," + "+nodes[o].n.type," d:",nodes[o].d," r:",nodes[o].r)});
                        var rank = nodes[outputs[0]].r;
                        var depth = nodes[outputs[0]].d;
                        for (var i = 1; i < outputs.length; i++) {
                            // console.log(outputs[i]);
                            var n = nodes[outputs[i]];
                            if (n.d !== depth && n.r === rank) {
                                // need to move n down one.
                                var r = n.r;
                                ns.forEach(function (_n) {
                                    var nn = nodes[_n.id];
                                    if (nn.d >= n.d && nn.d < depth && nn.r >= r) {
                                        pushed = true;
                                        nn.r++;
                                    }
                                })
                            }
                            depth = n.d;
                            rank = n.r;
                        }
                    }
                    node.o.forEach(function (n) {
                        pushed = pushed || shuffleRanks(nodes[n])
                    })
                    return pushed;
                }
                var shuffle = function () {
                    if (shuffleRanks(nodes[inputs[0]])) {
                        shuffle();
                    }
                }
                shuffle();


                var x = nodes[inputs[0]].n.x;
                var y = nodes[inputs[0]].n.y;
                var changedNodes = [];
                ns.forEach(function (n) {
                    var d = nodes[n.id].d;
                    var r = nodes[n.id].r;

                    changedNodes.push({
                        n: n,
                        ox: n.x,
                        oy: n.y,
                        moved: n.moved
                    });

                    n.x = x + d * 200;
                    n.y = y + r * 50;
                    n.dirty = true;
                    // n.dirtyStatus = true;
                    // n.status = {
                    //     text:"d"+d+" : r"+r+" : ds"+nodes[n.id].downstream
                    // }
                });

                if (changedNodes.length > 0) {
                    RED.history.push({ t: "move", nodes: changedNodes, dirty: RED.nodes.dirty() });
                    RED.nodes.dirty(true);
                    RED.view.redraw(true);
                }
                
                break;

        }
    }


    // Make sure the editor is completely loaded, before filling the sidebar with content.
    // Because only just before that, RED.nodes will be loaded.  Otherwise RED.nodes.getType("auto_layout_config") would 
    // return undefined, and RED.nodes.add would throw an exception...
    // The problem is that Node-RED does not offer an "editor-loaded" event.
    // I did a feature request for that, but for some obscure reason it was not accepted...
    // (see https://discourse.nodered.org/t/new-editor-event-when-all-nodes-have-been-loaded/60314)
    // On Discourse there was a workaround shared, but the 'workspace:change' is emitted a bit too early.
    // Because it is emitted just before the config nodes are loaded, so RED.nodes.eachConfig above would not find our config node.
    // (see https://discourse.nodered.org/t/add-sidebar-tab-on-app-start-not-working/64726/4).
    // I found that the 'runtime-state' event is triggered just after the config nodes are loaded, so it works fine. 
    // But it is a non-official unpublished event, so it might be changed or removed in the future...
    var dothisOneTimePlease = () => {
        RED.events.off('runtime-state', dothisOneTimePlease )

        // Register an action so the user could bind a keyboard shortcut to show the auto-layout sidebar
        // but avoid an "Error: Cannot override existing action" error in the browser console:
        if( RED.actions.list().filter( (d) => { return d.id == "core:auto-layout-flow"} ).length == 0 ) {
            RED.actions.add("core:auto-layout-flow", executeAutoLayout);
        }
        
        // The html content of the sidebar has been specified below as a data-template, from where it can be loaded:
        var content = $($('script[type="text/x-red"][data-template-name="auto_layout_sidebar"]').i18n().html());
       
        // Add a "Auto Layout" tabsheet to the right sidebar panel, in which this sidebar panel can be displayed
        RED.sidebar.addTab({
            id: "ai-sidebar",
            label: "MIS", // short name for the tab
            name: "AIåŠ©æ‰‹", // long name for the menu
            content: content,
            closeable: true,
            disableOnEdit: true,
            iconClass: "fa fa-comment"
        });

        // Show the algorithm settings as json in a typedinput element (in the sidebar)
        $("#node-input-settings").typedInput({
            default: 'json',
            types:['json']
        });

        // When the algorithm properties are changed in the sidebar, then store them into the config node
        $("#node-input-settings").on("change", function() {
            ensureAutoLayoutConfigNode();

            let currentAlgorithmSettings = $(this).typedInput('value');
            let currentAlgorithm = globalAutoLayoutConfigNode.algorithm;

            // When the property value has changed, save it in the config node and activate the 'deploy' button.
            // Remark: don't check the input type (i.e. use != instead of  !==) because we will get the number values as strings...
            //if (globalAutoLayoutConfigNode.settings[currentAlgorithm] != currentAlgorithmSettings) {
                let settingsObj = JSON.parse(globalAutoLayoutConfigNode.settings);
                settingsObj[currentAlgorithm] = JSON.parse(currentAlgorithmSettings);
                globalAutoLayoutConfigNode.settings = JSON.stringify(settingsObj);
                RED.nodes.dirty(true);
            //}
        })

        // When the algorithm is changed in the sidebar, then store it into the config node
        $("#node-input-algorithm").on("change", function() {
            ensureAutoLayoutConfigNode();

            let currentAlgorithm = $(this).val();
            let currentAlgorithmSettings = JSON.parse(globalAutoLayoutConfigNode.settings)[currentAlgorithm];

            // When the property value has changed, save it in the config node and activate the 'deploy' button.
            // Remark: don't check the input type (i.e. use != instead of  !==) because we will get the number values as strings...
            if (globalAutoLayoutConfigNode.algorithm != currentAlgorithm) {
                globalAutoLayoutConfigNode.algorithm = currentAlgorithm;
                RED.nodes.dirty(true);
            }
            
            $("#node-input-settings").typedInput('value', JSON.stringify(currentAlgorithmSettings));
        })
        $("#node-input-algorithm").change();

        $("#auto-layout-button").click( executeAutoLayout );

        $("#auto-layout-revert-button").click(function() {
            // revert the last change by calling undo but also maintain the 
            // original selection, making it easier to try out different 
            // algorithms.
            var sle = RED.view.selection();

            // this will clear the selection, hence make a copy beforehand
            RED.actions.invoke("core:undo");

            RED.view.select(sle);
        })

        $("#show-config-node-button").on("click", function() {
            console.log("æŒ‰é’®è¢«ç‚¹å‡»äº†");
            
            try {
                // æ£€æŸ¥RED.nodesæ˜¯å¦å·²å®šä¹‰
                if (!RED || !RED.nodes || typeof RED.nodes.getType !== 'function') {
                    console.error("RED.nodesæœªå®šä¹‰æˆ–ä¸å®Œæ•´");
                    RED.notify("RED.nodesæœªå®šä¹‰æˆ–ä¸å®Œæ•´", "error");
                    return;
                }
                
                // æ£€æŸ¥api-configèŠ‚ç‚¹ç±»å‹æ˜¯å¦å·²æ³¨å†Œ
                var apiConfigNodeType = RED.nodes.getType("api-config");
                if (!apiConfigNodeType) {
                    console.error("api-configèŠ‚ç‚¹ç±»å‹æœªæ³¨å†Œ");
                    RED.notify("api-configèŠ‚ç‚¹ç±»å‹æœªæ³¨å†Œï¼Œè¯·ç¡®ä¿èŠ‚ç‚¹å·²æ­£ç¡®åŠ è½½", "error");
                    return;
                }
                console.log("api-configèŠ‚ç‚¹ç±»å‹å·²æ³¨å†Œ");
                
                // æŸ¥æ‰¾api-configç±»å‹çš„èŠ‚ç‚¹
                var apiConfigNodes = [];
                RED.nodes.eachConfig(function(configNode) {
                    if (configNode.type === 'api-config') { 
                        apiConfigNodes.push(configNode); 
                        console.log("æ‰¾åˆ°api-configèŠ‚ç‚¹:", configNode.id, configNode.name);
                    }
                });
                
                if (apiConfigNodes.length > 0) {
                    console.log("æ‰¾åˆ°api-configèŠ‚ç‚¹ï¼Œæ‰“å¼€ç¼–è¾‘ç•Œé¢");
                    // ä½¿ç”¨ç¬¬ä¸€ä¸ªæ‰¾åˆ°çš„api-configèŠ‚ç‚¹
                    RED.editor.editConfig("", "api-config", apiConfigNodes[0].id);
                } else {
                    console.log("æ²¡æœ‰æ‰¾åˆ°api-configèŠ‚ç‚¹ï¼Œç›´æ¥æ‰“å¼€ç¼–è¾‘å¯¹è¯æ¡†");
                    
                    // ä¸å°è¯•åˆ›å»ºèŠ‚ç‚¹ï¼Œè€Œæ˜¯ç›´æ¥æ‰“å¼€ç¼–è¾‘å¯¹è¯æ¡†
                    // è¿™å°†å…è®¸ç”¨æˆ·åˆ›å»ºä¸€ä¸ªæ–°çš„api-configèŠ‚ç‚¹
                    RED.editor.editConfig("", "api-config");
                }
            } catch (error) {
                console.error("å¤„ç†è¿‡ç¨‹ä¸­å‘ç”Ÿé”™è¯¯:", error);
                RED.notify("æ˜¾ç¤ºé…ç½®èŠ‚ç‚¹æ—¶å‡ºé”™: " + error.message, "error");
            }
            
            // åˆå§‹åŒ–AIåŠ©æ‰‹UI
            setupAIAssistant();
            
            // åˆå§‹åŒ–å½“å‰flowåç§°æ˜¾ç¤º
            updateCurrentFlowName();
            
            // åˆå§‹åŒ–å½“å‰é€‰ä¸­èŠ‚ç‚¹ä¿¡æ¯
            updateSelectedNodeInfo();
            
            // ç›‘å¬workspaceé€‰æ‹©å˜åŒ–
            RED.events.on('workspace:change', updateCurrentFlowName);
            
            // ç›‘å¬èŠ‚ç‚¹é€‰æ‹©å˜åŒ–
            RED.events.on('view:selection-changed', updateSelectedNodeInfo);
        });
    };
    RED.events.on('runtime-state', dothisOneTimePlease )
})();
//    // åœ¨RED.events.on('runtime-state')ä¸­æ·»åŠ ä»¥ä¸‹ä»£ç 
//     RED.events.on('runtime-state', function() {
//     });

</script>

<script type="text/x-red" data-template-name="auto_layout_sidebar">
    <div class="red-ui-sidebar-info">
        <div class="red-ui-sidebar-header red-ui-info-toolbar">
            <span class="button-group"><a id="show-config-node-button" class="red-ui-button red-ui-button-small selected" href="#">
                <i class="fa fa-cog"></i></a></span><div class="red-ui-searchBox-container red-ui-searchBox-compact"><i class="fa fa-search"></i>
                  <form class="red-ui-searchBox-form"><input type="text" data-i18n="[placeholder]sidebar.help.search" class="red-ui-searchBox-input" placeholder="æœç´¢å¸®åŠ©"></form>
                 <a class="red-ui-searchBox-clear" href="#"><i class="fa fa-times"></i></a>
                <span class="red-ui-searchBox-resultCount hide"></span>
            </div>
        </div>

        <div class="red-ui-debug-content red-ui-debug-content-list" id="augment-chat-messages" style="
            position: absolute; 
            top: 40px; 
            bottom: 130px; 
            left: 0; 
            right: 0; 
            overflow-y: auto; 
            padding: 20px 16px;
            background: #fafafa;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        ">
            <!-- èŠå¤©æ¶ˆæ¯å°†åœ¨è¿™é‡Œæ˜¾ç¤º -->
        </div>

        <!-- Augmentå·¥å…·UI -->
        <div id="augment-chat-container" class="augment-chat-container" style="
            position: absolute; 
            bottom: 0; 
            left: 0; 
            right: 0; 
            background: #ffffff; 
            border-top: 1px solid #e5e7eb;
            padding: 5px; 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        ">
            <!-- ä¸Šä¸‹æ–‡ä¿¡æ¯æ  -->
            <div class="augment-chat-context" style="
                font-size: 12px; 
                color: #6b7280; 
                padding: 12px 16px;
                background: #f9fafb;
                border-radius: 8px;
                border: 1px solid #f3f4f6;
            ">
                <div style="display: flex; align-items: center; flex-wrap: wrap; gap: 12px;">
                    <span style="display: flex; align-items: center;">
                        <i class="fa fa-sitemap" style="margin-right: 6px; color: #374151;"></i> 
                        <span id="current-flow-name" style="font-weight: 500; color: #1f2937;">æœªé€‰æ‹©æµç¨‹</span>
                    </span>
                    <span style="color: #d1d5db;">></span>
                    <span style="display: flex; align-items: center;">
                        <i class="fa fa-cube" style="margin-right: 6px; color: #374151;"></i>
                        <span id="current-selected-node" style="font-weight: 500; color: #1f2937;">æœªé€‰æ‹©èŠ‚ç‚¹</span>
                    </span>
                    <span id="selected-node-type-container" style="display: none;">
                        <span style="color: #d1d5db;">|</span>
                        <span style="color: #6b7280;">ç±»å‹: <span id="current-selected-node-type" style="font-weight: 500; color: #1f2937;"></span></span>
                    </span>
                </div>
            </div>
            
            <!-- è¾“å…¥æ¡†åŒºåŸŸ -->
            <div class="augment-chat-input-container" style="
                border: 1px solid #d1d5db;
                border-radius: 12px;
                background: #ffffff;
                position: relative;
                transition: border-color 0.2s, box-shadow 0.2s;
            " onfocus="this.style.borderColor='#3b82f6'; this.style.boxShadow='0 0 0 3px rgba(59, 130, 246, 0.1)'" onblur="this.style.borderColor='#d1d5db'; this.style.boxShadow='none'">
                <textarea id="augment-chat-input" placeholder="Ask or instruct Augment" 
                          style="
                              width: 100%; 
                              min-height: 80px; 
                              padding: 16px 60px 16px 16px; 
                              border: none;
                              border-radius: 12px; 
                              resize: none; 
                              outline: none; 
                              font-family: inherit; 
                              font-size: 14px; 
                              background: transparent; 
                              color: #374151; 
                              overflow: hidden;
                              line-height: 1.5;
                          "
                          rows="3"
                          onfocus="this.parentElement.style.borderColor='#3b82f6'; this.parentElement.style.boxShadow='0 0 0 3px rgba(59, 130, 246, 0.1)'"
                          onblur="this.parentElement.style.borderColor='#d1d5db'; this.parentElement.style.boxShadow='none'"></textarea>
                
                <!-- å·¥å…·æ  -->
                <div style="
                    position: absolute;
                    bottom: 12px;
                    right: 12px;
                    display: flex;
                    align-items: center;
                    gap: 8px;
                ">
                    <!-- å·¥å…·æŒ‰é’® -->
                    <div style="display: flex; gap: 4px;">
                        <button id="augment-attach-file" style="
                            background: none;
                            border: none;
                            color: #6b7280;
                            cursor: pointer;
                            padding: 6px;
                            border-radius: 6px;
                            font-size: 14px;
                            transition: all 0.2s;
                            display: flex;
                            align-items: center;
                            justify-content: center;
                        " onmouseover="this.style.background='#f3f4f6'" onmouseout="this.style.background='none'">
                            <i class="fa fa-paperclip"></i>
                        </button>
                        <button id="augment-at-mention" style="
                            background: none;
                            border: none;
                            color: #6b7280;
                            cursor: pointer;
                            padding: 6px;
                            border-radius: 6px;
                            font-size: 14px;
                            transition: all 0.2s;
                            display: flex;
                            align-items: center;
                            justify-content: center;
                        " onmouseover="this.style.background='#f3f4f6'" onmouseout="this.style.background='none'">
                            <i class="fa fa-at"></i>
                        </button>
                    </div>
                    
                    <!-- å‘é€æŒ‰é’® -->
                    <button id="augment-send" style="
                        background: #3b82f6;
                        border: none;
                        border-radius: 8px;
                        color: white;
                        padding: 8px 16px;
                        font-size: 13px;
                        font-weight: 500;
                        cursor: pointer;
                        transition: background-color 0.2s;
                        display: flex;
                        align-items: center;
                        gap: 6px;
                    " onmouseover="this.style.background='#2563eb'" onmouseout="this.style.background='#3b82f6'">
                        <i class="fa fa-paper-plane"></i>
                        Send
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- ä¿ç•™åŸæœ‰çš„é…ç½®éƒ¨åˆ† -->
    <div style="position: relative; height: 100%; margin: 15px; display: none;" id="auto-layout-config-panel">
        <label for="node-input-algorithm" style="margin-top: 25px"><i class="fa fa-terminal"></i> Algorithm</label>
        <select id="node-input-algorithm">
            <option value="dagre_lr">Dagre LR</option>
            <option value="dagre_longest_path">Dagre Longest Path</option>
            <option value="elkjs_mr_tree">ELKjs Mr. Tree</option>
            <option value="elkjs_layered_upwards">ELKjs Layered Upwards</option>
            <option value="elkjs_layered_downwards">ELKjs Layered Downwards</option>
            <option value="elkjs_box">ELKjs Box</option>
            <option value="pull_request_2267">Pull Request 2267</option></select>
        </select>

        <label for="node-input-settings" style="margin-top: 15px"><i class="fa fa-cog"></i> Settings</label>
        <input type="text" id="node-input-settings" style="width: 100%; margin-top: 30px">
        
        <button type="button" id="auto-layout-button" style="font-size: larger;width:100%;background-color: yellowgreen;color:white;border: none;height: 32px;margin-top: 30px;">Execute auto-layout</button>

        <button type="button" id="auto-layout-revert-button" style="font-size: smaller;width:50%;background-color: rgb(225, 119, 129); color: rgb(246, 246, 246); border: 1px solid rgb(173, 22, 37); height: 32px; margin-top: 30px;"><i class="fa fa-undo"></i> Undo</button>

        <button id="show-config-node-button" class="red-ui-button">æ˜¾ç¤ºé…ç½®èŠ‚ç‚¹</button>
    </div>
</script>

<script type="text/javascript">
 
</script>
